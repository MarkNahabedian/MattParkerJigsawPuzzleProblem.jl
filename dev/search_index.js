var documenterSearchIndex = {"docs":
[{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"EditURL = \"../../src/MattParkerJigsawPuzzleProblem.jl\"","category":"page"},{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"module MattParkerJigsawPuzzleProblem\n\nusing Markdown\nusing Literate\nusing InteractiveUtils\nusing Random\n\ninclude(\"edges.jl\")\ninclude(\"grid.jl\")\ninclude(\"puzzle_pieces.jl\")\ninclude(\"solved_puzzle.jl\")\n\nend","category":"page"},{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"","category":"page"},{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"EditURL = \"../../src/grid.jl\"","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"export CardinalDirection, N, E, S, W\nexport opposite, next, previous\nexport cardinal_directions_from\nexport do_cardinal_directions\nexport edge_direction","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Puzzle pieces are assembled into a grid when the puzzle is being put together.  That grid has some number of rows and columns.  For a given row and column the grid has a cell which can be associated with the puzzle piece that belongs there.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"The grid has three kinds of cells: corner, edge, and middle.  If a grid has R rows and C columns, it will have R × C cells. No matter the size of the grid, it will have 4 corner cells.  The number of edge cells is 2 × (R - 2) + 2 * (C - 2).  The remaining (R - 2) × (C - 2) cells are middle cells.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Each cell has four neighbors, one in each of the cardinal compass directions.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"abstract type CardinalDirection end\nstruct N <: CardinalDirection end\nstruct E <: CardinalDirection end\nstruct S <: CardinalDirection end\nstruct W <: CardinalDirection end","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"There are various relationships among the CardinalDirections: opposite, next, and previous.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"\"\"\"\n    opposite(::CardinalDirection)::CardinalDirection\n\nReturns the opposite direction.  `N()` and `S()` are opposites.\n`E()` and `W()` are opposites.\n\"\"\"\nopposite(::N) = S()\nopposite(::E) = W()\nopposite(::S) = N()\nopposite(::W) = E()\n\n\"\"\"\n    next(::CardinalDirection)::CardinalDirection\n\nReturns the next direction clockwise from the given direction.\n\"\"\"\nnext(::N) = E()\nnext(::E) = S()\nnext(::S) = W()\nnext(::W) = N()\n\n\"\"\"\n    previous(::CardinalDirection)::CardinalDirection\n\nReturns the previous direction, that which is counter-clockwise,\nfrom the given direction.\n\"\"\"\nprevious(::N) = W()\nprevious(::E) = N()\nprevious(::S) = E()\nprevious(::W) = S()","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Starting from a given CardinalDirection, we can identify a sequence of all of the CardinalDirections in clockwise order.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"\"\"\"\n    cardinal_directions_from(d::CardinalDirection)\n\nReturns the four caerdinal directions, starting with `d`, in `next`\norder.\n\"\"\"\ncardinal_directions_from(d::CardinalDirection) =\n    (d, next(d), next(next(d)), next(next(next(d))))","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"do_cardinal_directions allows us to easily iterate over the cardinal directions, either clockwise or in a raandom order.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"\"\"\"\n    do_cardinal_directions(f; randomize=false)\n\nApplies the function `f` to each of the four `CardinalDirection`s.\n\nIf `randomize` is true then the directions are considered in random\norder.\n\"\"\"\nfunction do_cardinal_directions(f; randomize=false)\n    directions = cardinal_directions_from(N())\n    if randomize\n        directions = Random.shuffle(collect(directions))\n    end\n    for d in directions\n        f(d)\n    end\nend","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Given the row and column indices of a grid cell, and a CardinalDirection, we can compute the coordinates of the neighboring cell in that direction.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Each instance of a CardinalDirection serves as an operator for going from one pair of row/coumn indices to the neighboring ones in that direction.  As these operators don't know the size of the grid, bounds checking must be by their callers.done","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"(::N)(row, col) = [row - 1, col]\n(::E)(row, col) = [row,     col + 1]\n(::S)(row, col) = [row + 1, col]\n(::W)(row, col) = [row,     col - 1]","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Which edge of a puzzle piece is facing a given CardinalDirection depends on the rotation of that piece.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"The rotation of a puzzle piece is represented by one of the integers 0, 1, 2, or 3, also in clockwise order.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"\"\"\"\n    edge_direction(rotation::Int, edge_index::Int)::CardinalDirection\n\nFor the specified `edge_index` and rotation of a puzzle piece, return\nthe `CardinalDirection` that that edge faces.\n\"\"\"\nfunction edge_direction(piece_rotation::Int, edge_index::Int)::CardinalDirection\n    @assert piece_rotation in 0:3\n    direction = cardinal_directions_from(N())[mod(edge_index, Base.OneTo(4))]\n    while piece_rotation > 0\n        direction = previous(direction)\n        piece_rotation -= 1\n    end\n    direction\nend","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"This page was generated using Literate.jl.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"EditURL = \"../../src/puzzle_pieces.jl\"","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"A jigsaw puzzle is constructed as a two dimensional grid of pieces.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"Each piece has four edges, which we can identify using the small positive integers 1, 2, 3, and 4 (edge indices), which identify the piece's edges in clockwise order.  An edge is modeled by Edge.  A puzzle piece is basically a mapping from one of the four edge indices to an Edge.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"In the solution of a puzzle, each piece should have a unique location in that grid and be in one of four rotations.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"\"\"\"\n    AbstractPuzzlePiece\n\nAbstractPuzzlePiece is the abstract supertype for all types of jigsaw\npuzzle piece.\n\"\"\"\nabstract type AbstractPuzzlePiece end\n\n\n\"\"\"\n    piece_edge(puzzle_piece, edge_index)::Edge\n\nReturns the [`Edge`](@ref) of `puzzle_piece` which corresponds to the\nspecified `edge_index`.\n\"\"\"\nfunction piece_edge(::AbstractPuzzlePiece, edge_index)::Edge\n    error(\"piece_edge has no implementation for AbstractPuzzlePiece.\")\nend","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"EditURL = \"../../src/solved_puzzle.jl\"","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"export SolvedPuzzlePiece, SolvedPuzzle\nexport assign_perimeter_edges, assign_unique_unassigned_edges","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"We can construct a solved puzzle of a specified size by creating puzzle pieces that fit together into a solution.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"In the solution of a puzzle, each piece has a unique location (row and column) and one of four rotations.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"Each edge of a piece, in its solved orientation, can be identified by a cardinal compass direction: n, e, s, or w.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"For two puzzle pieces that share a vertical edge, the piece on the left's E edge will have the same EdgeType as that of the W edge of the piece on the right.  They will have opposite BallOrSockets.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"\"\"\"\n    SolvedPuzzlePiece(row, column)\n\nRepresents the piece of a `SolvedPuzzle` at the specified `row` and\n`column`.\n\nThe `edges` field is a `Dict` which maps from a `CardinalDirection`\nto and [`Edge`](@ref).\n\"\"\"\nstruct SolvedPuzzlePiece\n    row::Int\n    col::Int\n    edges::Dict{CardinalDirection, Edge}\n\n    function SolvedPuzzlePiece(row, col)\n        new(row, col, Dict{CardinalDirection, Edge}())\n    end\nend\n\n\n\"\"\"\n    SolvedPuzzle(rows, columns)\n\nConstructs a `SolvedPuzzle` with the specified numbers of rows and\ncolumns.\n\nThe `grid` field is populated with `SolvedPuzzlePiece`s.\n\"\"\"\nstruct SolvedPuzzle\n    grid\n\n    function SolvedPuzzle(rows::Int, columns::Int)\n        sp = new(Array{SolvedPuzzlePiece, 2}(undef, rows, columns))\n        for r in 1:rows\n            for c in 1:columns\n                sp.grid[r, c] = SolvedPuzzlePiece(r, c)\n            end\n        end\n        sp\n    end\nend","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"It is conventient for SolvedPuzzle to serve as an indexible surrogate for its own grid of puzzle pieces.  We need getindex but not setindex!.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"For out ofbounds indecies we just return nothing rather than throwing an error.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"Base.size(sp::SolvedPuzzle) = size(sp.grid)\n\nBase.IndexStyle(sp::SolvedPuzzle) = IndexCartesian()\n\nfunction Base.getindex(sp::SolvedPuzzle, row::Int, col::Int)\n    (rows, cols) = size(sp)\n    if row < 1 || row > rows || col < 1 || col > cols\n        return nothing\n    end\n    sp.grid[row, col]\nend","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"We randomize the order of the EdgeTypes so they don't hint at the solution.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"\"\"\"\n    random_edge_types(count, is_perimeter)\n\nCreate the specified number of unique [`EdgeType`](@ref)s\nand returns them in a random order.\n\"\"\"\nfunction random_edge_types(count, is_perimeter)\n    edge_types = []\n    for _ in 1:count\n        push!(edge_types, EdgeType(is_perimeter))\n    end\n    shuffle(edge_types)\nend\n\n\n\"\"\"\n    assign_perimeter_edges(SolvedPuzzle)::SolvedPuzzle\n\nAssigns a unique [`EdgeType`](@ref) to the perimeter edge of each of\nthe perimeter puzzle pieces.\n\nThe `SolvedPuzzle` is returned.\n\"\"\"\nfunction assign_perimeter_edges(sp::SolvedPuzzle)::SolvedPuzzle\n    (rows, cols) = size(sp)\n    # We randomize the order of the EdgeTypes so they don't hint at\n    # the solution.\n    edge_types = random_edge_types(2 * rows + 2 * cols, true)\n    for r in 1:rows\n        # Top and bottom edges:\n        sp.grid[r, 1].edges[W()] = Edge(pop!(edge_types), Ball())\n        sp.grid[r, cols].edges[E()] = Edge(pop!(edge_types), Ball())\n    end\n    for c in 1:cols\n        # Left and right edges:\n        sp.grid[1, c].edges[N()] = Edge(pop!(edge_types), Ball())\n        sp.grid[rows, c].edges[S()] = Edge(pop!(edge_types), Ball())\n    end\n    sp\nend\n\n\n\"\"\"\n    assign_unique_unassigned_edges(sp::SolvedPuzzle)::SolvedPuzzle\n\nAssigns an [`EdgeType`](@ref)] to each of the *internal* edges of the\npuzzle.\n\nThe `SolvedPuzzle` is returned.\n\"\"\"\nfunction assign_unique_unassigned_edges(sp::SolvedPuzzle)::SolvedPuzzle\n    (rows, cols) = size(sp)","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"It's ok to create too many EdgeTypes, they're cheap:","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"    edge_types = random_edge_types(4 * rows * cols / 2, false)\n    for r in 1:rows\n        for c in 1:cols\n            do_cardinal_directions(; randomize=true) do direction\n                piece = sp[r, c]\n                if !haskey(piece.edges, direction)\n                    # Edge not yet assigned\n                    new_edge_type = pop!(edge_types)\n                    neignbor =\n                        sp[direction(piece.row, piece.col)...]\n                    # Maybe we should randomize which BallOrSocket to\n                    # use, but why bother?\n                    piece.edges[direction] = Edge(new_edge_type, Ball())\n                    if neignbor != nothing\n                        neignbor.edges[opposite(direction)] =\n                            Edge(new_edge_type, Socket())\n                    end\n                end\n            end\n        end\n    end\n    sp\nend","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MattParkerJigsawPuzzleProblem","category":"page"},{"location":"#MattParkerJigsawPuzzleProblem","page":"Home","title":"MattParkerJigsawPuzzleProblem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MattParkerJigsawPuzzleProblem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this YouTube video Matt Parker asks for a program to help design and solve jigsaw puzzles.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The idea is to produce a set of jigsaw puzzle pieces where the pieces can be assembled in more than one way, and, ideally, in exactly two ways.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is an attempt at that.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Descriptions","page":"Home","title":"Descriptions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [MattParkerJigsawPuzzleProblem]","category":"page"},{"location":"#MattParkerJigsawPuzzleProblem.ALL_EDGE_TYPES","page":"Home","title":"MattParkerJigsawPuzzleProblem.ALL_EDGE_TYPES","text":"ALL_EDGE_TYPES\n\nALL_EDGE_TYPES is a vector of all of the EdgeTypes that have been created.\n\n\n\n\n\n","category":"constant"},{"location":"#MattParkerJigsawPuzzleProblem.AbstractPuzzlePiece","page":"Home","title":"MattParkerJigsawPuzzleProblem.AbstractPuzzlePiece","text":"AbstractPuzzlePiece\n\nAbstractPuzzlePiece is the abstract supertype for all types of jigsaw puzzle piece.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.Edge","page":"Home","title":"MattParkerJigsawPuzzleProblem.Edge","text":"Edge(::EdgeType, ::BallOrSocket)\n\nEdge represents one edge of a puzzle piece.  It has an edge_type. The bs field indicates whether the edge is a ball or socket.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.EdgeType","page":"Home","title":"MattParkerJigsawPuzzleProblem.EdgeType","text":"EdgeType(isperimeter::Bool)\n\nCreates a unique EdgeType.\n\nisperimeter indicates if the EdgeType is for an edge on the perimeter of the puzzle.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.SolvedPuzzle","page":"Home","title":"MattParkerJigsawPuzzleProblem.SolvedPuzzle","text":"SolvedPuzzle(rows, columns)\n\nConstructs a SolvedPuzzle with the specified numbers of rows and columns.\n\nThe grid field is populated with SolvedPuzzlePieces.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.SolvedPuzzlePiece","page":"Home","title":"MattParkerJigsawPuzzleProblem.SolvedPuzzlePiece","text":"SolvedPuzzlePiece(row, column)\n\nRepresents the piece of a SolvedPuzzle at the specified row and column.\n\nThe edges field is a Dict which maps from a CardinalDirection to and Edge.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.assign_perimeter_edges-Tuple{SolvedPuzzle}","page":"Home","title":"MattParkerJigsawPuzzleProblem.assign_perimeter_edges","text":"assign_perimeter_edges(SolvedPuzzle)::SolvedPuzzle\n\nAssigns a unique EdgeType to the perimeter edge of each of the perimeter puzzle pieces.\n\nThe SolvedPuzzle is returned.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.assign_unique_unassigned_edges-Tuple{SolvedPuzzle}","page":"Home","title":"MattParkerJigsawPuzzleProblem.assign_unique_unassigned_edges","text":"assign_unique_unassigned_edges(sp::SolvedPuzzle)::SolvedPuzzle\n\nAssigns an EdgeType] to each of the internal edges of the puzzle.\n\nThe SolvedPuzzle is returned.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.cardinal_directions_from-Tuple{CardinalDirection}","page":"Home","title":"MattParkerJigsawPuzzleProblem.cardinal_directions_from","text":"cardinal_directions_from(d::CardinalDirection)\n\nReturns the four caerdinal directions, starting with d, in next order.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.do_cardinal_directions-Tuple{Any}","page":"Home","title":"MattParkerJigsawPuzzleProblem.do_cardinal_directions","text":"do_cardinal_directions(f; randomize=false)\n\nApplies the function f to each of the four CardinalDirections.\n\nIf randomize is true then the directions are considered in random order.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.edge_direction-Tuple{Int64, Int64}","page":"Home","title":"MattParkerJigsawPuzzleProblem.edge_direction","text":"edge_direction(rotation::Int, edge_index::Int)::CardinalDirection\n\nFor the specified edge_index and rotation of a puzzle piece, return the CardinalDirection that that edge faces.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.edges_match-Tuple{Edge, Edge}","page":"Home","title":"MattParkerJigsawPuzzleProblem.edges_match","text":"edges_match(::Edge, ::Edge)::Bool\n\nTwo Edges match if they have the same EdgeType and their bss are opposites.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.next-Tuple{N}","page":"Home","title":"MattParkerJigsawPuzzleProblem.next","text":"next(::CardinalDirection)::CardinalDirection\n\nReturns the next direction clockwise from the given direction.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.opposite-Tuple{N}","page":"Home","title":"MattParkerJigsawPuzzleProblem.opposite","text":"opposite(::CardinalDirection)::CardinalDirection\n\nReturns the opposite direction.  N() and S() are opposites. E() and W() are opposites.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.piece_edge-Tuple{MattParkerJigsawPuzzleProblem.AbstractPuzzlePiece, Any}","page":"Home","title":"MattParkerJigsawPuzzleProblem.piece_edge","text":"piece_edge(puzzle_piece, edge_index)::Edge\n\nReturns the Edge of puzzle_piece which corresponds to the specified edge_index.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.previous-Tuple{N}","page":"Home","title":"MattParkerJigsawPuzzleProblem.previous","text":"previous(::CardinalDirection)::CardinalDirection\n\nReturns the previous direction, that which is counter-clockwise, from the given direction.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.random_edge_types-Tuple{Any, Any}","page":"Home","title":"MattParkerJigsawPuzzleProblem.random_edge_types","text":"random_edge_types(count, is_perimeter)\n\nCreate the specified number of unique EdgeTypes  and returns them in a random order.\n\n\n\n\n\n","category":"method"},{"location":"edges/","page":"Edges","title":"Edges","text":"EditURL = \"../../src/edges.jl\"","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"export ALL_EDGE_TYPES, EdgeType, BallOrSocket, Ball, Socket\nexport opposite, Edge, edges_match","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We define some number of \"edge types\".  If the puzzle pieces are all square, then there is only one edge type.  If they are rectangular then there are two edge types: one for each edge length.  Each different shape of interlocking edge represents another edge type.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"MORE PRACTICALLY THOUGH: since we don't want to match two puzzle pieces on a flat perimeter edge, each edge on the perimeter of the puzzle should have a different edge type.  For a 3 by 5 puzzle, that gives 16 edge types before you start defining edge types for the internal edges.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We define EdgeType and create an instance for each distinct edge type. All an EdgeType needs is uniqueness.  It might be handy to note if the EdgeType represents a perimeter edge though, so we track that.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We accumulate a catalog of every EdgeType in ALL_EDGE_TYPES.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"\"\"\"\n    ALL_EDGE_TYPES\n\n`ALL_EDGE_TYPES` is a vector of all of the `EdgeType`s that have been\ncreated.\n\"\"\"\nALL_EDGE_TYPES = []\n\nlet\n    NEXT_EDGE_UID = 1\n\n    struct EdgeType\n        isperimeter::Bool\n        uid::Int\n\n        function EdgeType(isperimeter)\n            et = new(isperimeter,\n                     let\n                         uid = NEXT_EDGE_UID\n                         NEXT_EDGE_UID += 1\n                         uid\n                     end)\n            push!(ALL_EDGE_TYPES, et)\n            return et\n        end\n    end\nend\n\n@doc \"\"\"\n    EdgeType(isperimeter::Bool)\n\nCreates a unique `EdgeType`.\n\n`isperimeter` indicates if the EdgeType is for an edge on the\nperimeter of the puzzle.\n\"\"\" EdgeType","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"At the edge where two puzzle pieces interlock, the edges of those pieces are mirror images of each other.  At that meeting edge, one piece has a ball and the other has a socket.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"The edge of a puzzle piece is thus characterized by its EdgeType and whether it is a ball or socket.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"Ball and Socket are opposites.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We arbitrarily decide that a perimeter edge is always a ball.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"abstract type BallOrSocket end\nstruct Ball <: BallOrSocket end\nstruct Socket <: BallOrSocket end\n\nopposite(::Ball) = Socket()\nopposite(::Socket) = Ball()\n\n\n\"\"\"\n    Edge(::EdgeType, ::BallOrSocket)\n\n`Edge` represents one edge of a puzzle piece.  It has an `edge_type`.\nThe `bs` field indicates whether the edge is a *ball* or *socket*.\n\n\"\"\"\nstruct Edge\n    edge_type::EdgeType\n    bs::BallOrSocket\nend","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"It is easier to index things if there is a total ordering defined for them.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"EdgeTypes can be ordered by their uid.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We arbitrarily decide that Ball comes before Socket.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We can then define a total ordering on Edges.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"function Base.isless(a::EdgeType, b::EdgeType)::Bool\n    a.uid < b.uid\nend\n\nfunction Base.isless(a::BallOrSocket, b::BallOrSocket)\n    false\nend\n\nfunction Base.isless(::Ball, ::Socket)\n    true\nend\n\nfunction Base.isless(a::Edge, b::Edge)\n    (isless(a.edge_type, b.edge_type) ||\n        (a.edge_type == b.edge_type &&\n        isless(a.bs, b.bs)))\nend","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"Two Edges match if they have the same EdgeType and their bss are opposites.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"\"\"\"\n    edges_match(::Edge, ::Edge)::Bool\n\nTwo `Edge`s match if they have the same `EdgeType` and their `bs`s are\nopposites.\n\"\"\"\nfunction edges_match(e1::Edge, e2::Edge)::Bool\n    (e1.edge_type == e2.edge_type) &&\n        (opposite(e1.bs) == e2.bs)\nend","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"This page was generated using Literate.jl.","category":"page"}]
}
