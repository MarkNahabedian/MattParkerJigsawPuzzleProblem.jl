var documenterSearchIndex = {"docs":
[{"location":"terse_representation/","page":"-","title":"-","text":"EditURL = \"../../src/terse_representation.jl\"","category":"page"},{"location":"terse_representation/","page":"-","title":"-","text":"using Printf\n\nexport terserep","category":"page"},{"location":"terse_representation/","page":"-","title":"-","text":"To help with debugging, we define a more terse representation of edges, puzzle pieces and grids.","category":"page"},{"location":"terse_representation/","page":"-","title":"-","text":"terserep(et::EdgeType) = @sprintf(\"%d\", et.uid)\n\nterserep(::Ball) = \"b\"\nterserep(::Socket) = \"s\"\nterserep(::Straight) = \"_\"\n\nterserep(::Nothing) = \"?\"\n\nterserep(edge::Edge) =\n    @sprintf(\"%s%s\",\n             terserep(edge.edge_type),\n             terserep(edge.bs))\n\nterserep(piece::AbstractPuzzlePiece) =\n    join(terserep.(piece.edges), \"/\")\n\nterserep(cell::GridCell) =\n    join(terserep.([ get_edge(cell, direction)\n                     for direction in CARDINAL_DIRECTIONS ]),\n         \"/\")\n\nterserep(::Missing) = \"#\"\n\nfunction terserep(grid::Grid)\n    (nrows, ncols) = size(grid)\n    for r in 1:nrows\n        for c in 1:ncols\n            print(terserep(grid[r, c]), \"\\t\")\n        end\n        println()\n    end\nend\n\n\n\n\"\"\"\n    terserep(puzzle)\n\nOutput a terse printed representation of the puzzle.\n\"\"\"\nfunction terserep(puzzle::MultipleSolutionPuzzle)\n    for grid in puzzle.grids\n        terserep(grid)\n        println()\n    end\nend","category":"page"},{"location":"terse_representation/","page":"-","title":"-","text":"","category":"page"},{"location":"terse_representation/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"multiple_solutions/","page":"-","title":"-","text":"EditURL = \"../../src/multiple_solutions.jl\"","category":"page"},{"location":"multiple_solutions/","page":"-","title":"-","text":"export MultipleSolutionPuzzle, perimeters, puzzle_pieces","category":"page"},{"location":"multiple_solutions/","page":"-","title":"-","text":"Matt Parker's YouTube video is about jigsaw puzzles that have more than one solution.  Here we attempt to construct such a puzzle by makiing one grid for each solution and placiing the same set of MutablePuzzlePieces, with different locations and orientations, in each grid.","category":"page"},{"location":"multiple_solutions/","page":"-","title":"-","text":"struct MultipleSolutionPuzzle\n    grids\n\n    # Iy might be simpler to populate the first grid with Pieces that\n    # have no edges yet, add the perimeter edges and then permute\n    # them for the other grids.\n    function MultipleSolutionPuzzle(number_of_rows, number_of_columns,\n                                    number_of_grids)\n        puzzle = new(map(_ -> new_grid(number_of_rows, number_of_columns),\n                         1:number_of_grids))\n        # Populate the first grid and set its perimeter edges:\n        grid1 = puzzle.grids[1]\n        corners = []\n        edges = []\n        middle = []\n        for r in 1:number_of_rows\n            for c in 1:number_of_columns\n                piece = MutablePuzzlePiece()\n                cell = GridCell(r, c, piece, rand(0:3))\n                grid1[r, c] = cell\n                perimeter_count = 0\n                if r == 1\n                    set_edge!(cell, N(), Edge(EdgeType(true), Straight()))\n                    perimeter_count += 1\n                elseif r == number_of_rows\n                    set_edge!(cell, S(), Edge(EdgeType(true), Straight()))\n                    perimeter_count += 1\n                end\n                if c == 1\n                    set_edge!(cell, W(), Edge(EdgeType(true), Straight()))\n                    perimeter_count += 1\n                elseif c == number_of_columns\n                    set_edge!(cell, E(), Edge(EdgeType(true), Straight()))\n                    perimeter_count += 1\n                end\n                if perimeter_count == 2\n                    push!(corners, piece)\n                elseif perimeter_count == 1\n                    push!(edges, piece)\n                elseif perimeter_count == 0\n                    push!(middle, piece)\n                else\n                    error(\"Puzzle is too small\")\n                end\n            end\n        end\n        # Populate the remaining grids with permutations of the\n        # pieces from grid1:\n        function cell_rotation(row, col, piece::MutablePuzzlePiece)\n            count_perimeters(pmtrs) = sum(p -> p == true, pmtrs)\n            cell_perimeters = perimeters(puzzle, row, col)\n            for rot in 0:3\n                piece_perimeters =\n                    [ isperimeter(piece.edges[i])\n                      for i in edge_index.((1:4) .+ rot) ]\n                @assert count_perimeters(cell_perimeters) ==\n                    count_perimeters(piece_perimeters)\n                if cell_perimeters == piece_perimeters\n                    return rot\n                end\n            end\n            @assert false \"Can't determine piece rotation.\"\n        end\n        for i in 2:number_of_grids\n            grid = puzzle.grids[i]\n            permuted_corners = Random.shuffle(corners)\n            permuted_edges = Random.shuffle(edges)\n            permuted_middle = Random.shuffle(middle)\n            for r in 1:number_of_rows\n                for c in 1:number_of_columns\n                    if r in [1, number_of_rows] && c in [1, number_of_columns]\n                        piece = pop!(permuted_corners)\n                    elseif (r in [1, number_of_rows] ||\n                        c in [1, number_of_columns])\n                        piece = pop!(permuted_edges)\n                    else\n                        piece = pop!(permuted_middle)\n                    end\n                    rotation = cell_rotation(r, c, piece)\n                    grid[r, c] = GridCell(r, c, piece, rotation)\n                end\n            end\n        end\n        # Make sure every piece is in every grid exactly once:\n        let\n            all_pieces = Set([corners..., edges..., middle...])\n            for grid in puzzle.grids\n                grid_pieces = Set()\n                for r in 1:number_of_rows\n                    for c in 1:number_of_columns\n                        push!(grid_pieces, grid[r, c].puzzle_piece)\n                    end\n                end\n                @assert all_pieces == grid_pieces\n            end\n        end","category":"page"},{"location":"multiple_solutions/","page":"-","title":"-","text":"Assign edges to every puzzle piece","category":"page"},{"location":"multiple_solutions/","page":"-","title":"-","text":"        function propagate_edge(edge::Edge, piece::MutablePuzzlePiece)\n            # edge is the one that was just set in piece.\n            # Propagate to the neighboring piece in each grid.\n            for gridi in 1:length(puzzle.grids)\n                grid = puzzle.grids[gridi]\n                cell = grid[findfirst(grid) do cell\n                                cell.puzzle_piece == piece\n                            end]\n                direction = direction_for_edge(cell, edge)\n                neighbor = direction(grid, cell)\n                @assert isa(neighbor, GridCell)\n                neighbor_edge = get_edge(neighbor, opposite(direction))\n                if ismissing(neighbor_edge)\n                    neighbor_edge = opposite(edge)\n                    set_edge!(neighbor, opposite(direction),\n                              neighbor_edge)\n                    propagate_edge(neighbor_edge, neighbor.puzzle_piece)\n                else\n                    # Neighbor already has an Edge facing us, so make\n                    # sure it matches:\n                    if !edges_mate(edge, neighbor_edge)\n                        println(\"Edges don't mate: $gridi $cell\\n$edge\\n$neighbor_edge\\n\")\n                    end\n                end\n            end\n        end\n        # Fill in the missing edges of grid1 and propagate the new\n        # edges:\n        for r in 1:number_of_rows\n            for c in 1:number_of_columns\n                for direction in CARDINAL_DIRECTIONS\n                    cell = grid1[r, c]\n                    if ismissing(get_edge(cell, direction))\n                        new_edge = Edge(EdgeType(false),\n                                        (Ball(), Socket())[rand(1:2)])\n                        set_edge!(cell, direction, new_edge)\n                        propagate_edge(new_edge, cell.puzzle_piece)\n                    end\n                end\n            end\n        end\n        terserep(puzzle)\n        # Make sure every cell has a puzzle piece with all four edges:\n        for g in 1:length(puzzle.grids)\n            grid = puzzle.grids[g]\n            for r in 1:number_of_rows\n                for c in 1:number_of_columns\n                    cell = grid[r, c]\n                    @assert(cell.puzzle_piece isa MutablePuzzlePiece,\n                            \"grid $g, cell $r $c is not a puzzle piece\")\n                    for direction in CARDINAL_DIRECTIONS\n                        @assert(!ismissing(get_edge(cell, direction)),\n                                \"grid, $g cell $r $c has no edge for $direction\")\n                    end\n                end\n            end\n        end\n        puzzle\n    end\nend\n\n\nBase.size(puzzle::MultipleSolutionPuzzle) = size(puzzle.grids[1])\n\n\n\"\"\"\n    perimeters(puzzle::MultipleSolutionPuzzle, row::Int, col::Int)\n\nReturns a four element vector indicating for each direction (N, E, S,\nW) whether that side of the cell at `row`, `col` is a perimeter of the\npuzzle.\n\"\"\"\nfunction perimeters(puzzle::MultipleSolutionPuzzle, row::Int, col::Int)\n    (nrows, ncols) = size(puzzle)\n    [\n        row == 1,\n        col == ncols,\n        row == nrows,\n        col == 1\n    ]\nend\n\n\nfunction check_puzzle(puzzle::MultipleSolutionPuzzle)\n    errors = []\n    (nrows, ncols) = size(puzzle)\n    for gridi in 1:length(puzzle.grids)\n        grid = puzzle.grids[gridi]\n        for r in 1:nrows\n            for c in 1:ncols\n                for d in [N(), E()]\n                    cell = grid[r, c]\n                    neighbor = d(grid, cell)\n                    cell_edge = get_edge(cell, d)\n                    neighbor_edge = get_edge(neighbor, opposite(d))\n                    if !edges_mate(cell_edge, neighbor_edge)\n                        push!(errors,\n                              \"$gridi $r $c $d: $cell_edge $neighbor_edge\")\n                    end\n                end\n            end\n        end\n    end\n    return isempty(erros), errors\nend\n\n\n\"\"\"\n    puzzle_pieces(puzzle::MultipleSolutionPuzzle)::Vector{MutablePuzzlePiece}\n\nReturns a vector of all of the `MutablePuzzlePiece`s of `puzzle`.\n\"\"\"\nfunction puzzle_pieces(puzzle::MultipleSolutionPuzzle)\n    pieces = []\n    for cell in puzzle.grids[1]\n        push!(pieces, cell.puzzle_piece)\n    end\n    pieces\nend","category":"page"},{"location":"multiple_solutions/","page":"-","title":"-","text":"","category":"page"},{"location":"multiple_solutions/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"EditURL = \"../../src/MattParkerJigsawPuzzleProblem.jl\"","category":"page"},{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"module MattParkerJigsawPuzzleProblem\n\nusing DataStructures\nusing InteractiveUtils\nusing Literate\nusing Markdown\nusing Random\n\ninclude(\"edges.jl\")\ninclude(\"puzzle_pieces.jl\")\ninclude(\"grid.jl\")\ninclude(\"multiple_solutions.jl\")\ninclude(\"terse_representation.jl\")\ninclude(\"grid_html.jl\")\n\nend","category":"page"},{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"","category":"page"},{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"EditURL = \"../../src/grid.jl\"","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"export CardinalDirection, N, E, S, W, CARDINAL_DIRECTIONS\nexport opposite, next, previous\nexport cardinal_directions_from\nexport do_cardinal_directions\nexport rotation, GridCell\nexport get_edge, set_edge!, direction_for_edge\nexport edge_direction, Grid, new_grid, get_neighboring_edge, fit_piece","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Puzzle pieces are assembled into a grid when the puzzle is being put together.  That grid has some number of rows and columns.  For a given row and column the grid has a cell which can be associated with the puzzle piece that belongs there.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"The grid has three kinds of cells: corner, edge, and middle.  If a grid has R rows and C columns, it will have R × C cells. No matter the size of the grid, it will have 4 corner cells.  The number of edge cells is 2 × (R - 2) + 2 * (C - 2).  The remaining (R - 2) × (C - 2) cells are middle cells.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Each cell has four neighbors, one in each of the cardinal compass directions.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"\"\"\"\n    GridCell(::AbstractPuzzlePiece, rotation::Int)\n\nA GridCell is the container for a puzzle piece in a puzzle grid.\n\"\"\"\nstruct GridCell\n    row::Int\n    col::Int\n    puzzle_piece\n    rotation::Int\n\n    GridCell(row, col, piece, rotation) =\n        new(row, col, piece, mod(rotation, 4))\nend\n\nconst Grid = Array{Union{Missing, GridCell}, 2}\n\n\"\"\"\n    new_grid(number_of_rows, number_of_columns)::Grid\n\nCreates an empty puzzle grid of the specified dimensions.\n\"\"\"\nnew_grid(number_of_rows, number_of_columns)::Grid =\n    Grid(missing, number_of_rows, number_of_columns)\n\n\nabstract type CardinalDirection end\nstruct N <: CardinalDirection end\nstruct E <: CardinalDirection end\nstruct S <: CardinalDirection end\nstruct W <: CardinalDirection end\n\nconst CARDINAL_DIRECTIONS = (N(), E(), S(), W())","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"There are various relationships among the CardinalDirections: opposite, next, and previous.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"\"\"\"\n    opposite(::CardinalDirection)::CardinalDirection\n\nReturns the opposite direction.  `N()` and `S()` are opposites.\n`E()` and `W()` are opposites.\n\"\"\"\nopposite(::N) = S()\nopposite(::E) = W()\nopposite(::S) = N()\nopposite(::W) = E()\n\n\"\"\"\n    next(::CardinalDirection)::CardinalDirection\n\nReturns the next direction clockwise from the given direction.\n\"\"\"\nnext(::N) = E()\nnext(::E) = S()\nnext(::S) = W()\nnext(::W) = N()\n\n\"\"\"\n    previous(::CardinalDirection)::CardinalDirection\n\nReturns the previous direction, that which is counter-clockwise,\nfrom the given direction.\n\"\"\"\nprevious(::N) = W()\nprevious(::E) = N()\nprevious(::S) = E()\nprevious(::W) = S()\n\nedge_index(::N) = 1\nedge_index(::E) = 2\nedge_index(::S) = 3\nedge_index(::W) = 4","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Starting from a given CardinalDirection, we can identify a sequence of all of the CardinalDirections in clockwise order.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"\"\"\"\n    cardinal_directions_from(d::CardinalDirection)\n\nReturns the four caerdinal directions, starting with `d`, in `next`\norder.\n\"\"\"\ncardinal_directions_from(d::CardinalDirection) =\n    (d, next(d), next(next(d)), next(next(next(d))))","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"do_cardinal_directions allows us to easily iterate over the cardinal directions, either clockwise or in a raandom order.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"\"\"\"\n    do_cardinal_directions(f; randomize=false)\n\nApplies the function `f` to each of the four `CardinalDirection`s.\n\nIf `randomize` is true then the directions are considered in random\norder.\n\"\"\"\nfunction do_cardinal_directions(f; randomize=false)\n    directions = cardinal_directions_from(N())\n    if randomize\n        directions = Random.shuffle(collect(directions))\n    end\n    for d in directions\n        f(d)\n    end\nend","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Given the row and column indices of a grid cell, and a CardinalDirection, we can compute the coordinates of the neighboring cell in that direction.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Each instance of a CardinalDirection serves as an operator for going from one pair of row/coumn indices to the neighboring ones in that direction.  As these operators don't know the size of the grid, bounds checking must be by their callers.done","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"(::N)(row::Int, col::Int) = [row - 1, col]\n(::E)(row::Int, col::Int) = [row,     col + 1]\n(::S)(row::Int, col::Int) = [row + 1, col]\n(::W)(row::Int, col::Int) = [row,     col - 1]","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Which edge of a puzzle piece is facing a given CardinalDirection depends on the rotation of that piece.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"The rotation of a puzzle piece is represented by one of the integers 0, 1, 2, or 3, also in clockwise order.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"\"\"\"\n    rotation(rot::Int)\n\nNormalizes the rotation of the placement of a puzzle piece to one of\n0, 1, 2, or 3.\n\"\"\"\nrotation(r::Int) = mod(r, 4)\n\n\nImmutablePuzzlePiece(cell::GridCell) =\n    ImmutablePuzzlePiece(cell.puzzle_piece)","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Within a grid, a GridCell has a neighbor in each direction.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"(cd::CardinalDirection)(gc::GridCell) = cd(gc.row, gc.col)\n\nfunction (cd::CardinalDirection)(grid::Grid, row::Int, col::Int)\n    (r, c) = cd(row, col)\n    (nrows, ncols) = size(grid)\n    if !(r in 1:nrows) || !(c in 1:ncols)\n        return missing\n    end\n    return grid[r, c]\nend\n\n(cd::CardinalDirection)(grid::Grid, cell::GridCell) =\n    cd(grid, cell.row, cell.col)\n\n\nfunction get_edge(gc::GridCell, direction::CardinalDirection)\n    i = edge_index(edge_index(direction) + gc.rotation)\n    gc.puzzle_piece.edges[i]\nend\n\nfunction set_edge!(gc::GridCell, direction::CardinalDirection,\n                   edge::Edge)\n    i = edge_index(edge_index(direction) + gc.rotation)\n    gc.puzzle_piece.edges[i] = edge\nend\n\nisperimeter(cell::GridCell, direction::CardinalDirection) =\n    isperimeter(get_edge(cell, direction))\n\nfunction direction_for_edge(cell::GridCell, edge::Edge)\n    for d in CARDINAL_DIRECTIONS\n        e = get_edge(cell, d)\n        if e isa Edge\n            if e == edge\n                return d\n            end\n        end\n    end\n    return missing\nend\n\n\n\"\"\"\n    edge_direction(rotation::Int, index::Int)::CardinalDirection\n\nFor the specified `edge_index` and rotation of a puzzle piece, return\nthe `CardinalDirection` that that edge faces.\n\"\"\"\nfunction edge_direction(piece_rotation::Int, index::Int)::CardinalDirection\n    @assert piece_rotation in 0:3\n    direction = cardinal_directions_from(N())[edge_index(index)]\n    while piece_rotation > 0\n        direction = previous(direction)\n        piece_rotation -= 1\n    end\n    direction\nend\n\n\n\"\"\"\n    perimeter_edge_indices(grid::Grid, row::int, col::Int)\n\nReturns a vector of the indices of edges of the specified cell of\n`grid` that are perimeter edges.\n\"\"\"\nfunction perimeter_edge_indices(grid::Grid, row::Int, col::Int)\n    indices = []\n    (nrows, ncols) = size(grid)\n    if row == 1;      push!(indices, 1); end\n    if col == ncols;  push!(indices, 2); end\n    if row == nrows;  push!(indices, 3); end\n    if col == 1;      push!(indices, 4); end\n    indices\nend\n\n\"\"\"\n   get_neighboring_edge(grid::Grid, row::Int, col::Int, direction::CardinalDirection)\n\nReturns the `Edge` of the \"neighboring cell\" to the specified grid\nlocation.  If that location is out of bounds then `Edge(EdgeType(true,\n0), Straight())` is returned.  Otherwise, if there is no GridCell at\nthe specified location yet, then `missing` is returned.\n\"\"\"\nfunction get_neighboring_edge(grid::Grid, row::Int, col::Int,\n                              direction::CardinalDirection)\n    (nrows, ncols) = size(grid)\n    neighbor_indices = direction(row, col)\n    if (neighbor_indices[1] < 1 ||\n        neighbor_indices[1] > nrows ||\n        neighbor_indices[2] < 1 ||\n        neighbor_indices[2] > ncols\n        )\n        return Edge(EdgeType(true, 0), Straight())\n    else\n        cell = grid[neighbor_indices...]\n        if cell isa GridCell\n            return get_edge(cell, opposite(direction))\n        end\n    end\n    return missing\nend\n\n\n\"\"\"\n    fit_piece(continuation, grid::Grid, row::Int, col::Int,\n                   piece::ImmutablePuzzlePiece)\n\nAttempts to fit `piece` into the specified location of `grid`.\n`continuation` is called for each rotation of `piece` that fits.\n\"\"\"\nfunction fit_piece(continuation, grid::Grid, row::Int, col::Int,\n                   piece::ImmutablePuzzlePiece)","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"If the piece fits at the specified location in grid, call continuation with the rotation of the piece.","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"    for rot in 0:3\n        for d in CARDINAL_DIRECTIONS\n            piece_edge = piece.edges[edge_index(rot + edge_index(d))]\n            neighbor_edge = get_neighboring_edge(grid, row, col, d)\n            if ismissing(neighbor_edge)\n                continue\n            end\n            if !edges_mate(piece_edge, neighbor_edge)\n                @goto no_fit\n            end\n        end\n        continuation(rot)\n        @label no_fit\n    end\nend","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"This page was generated using Literate.jl.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"EditURL = \"../../src/puzzle_pieces.jl\"","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"export edge_index\nexport AbstractPuzzlePiece, perimeter_edge_indices\nexport MutablePuzzlePiece, ImmutablePuzzlePiece\nexport mating_piece_indices","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"A jigsaw puzzle is constructed as a two dimensional grid of pieces.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"Each piece has four edges, which we can identify using the small positive integers 1, 2, 3, and 4 (edge indices), which identify the piece's edges in clockwise order.  An edge is modeled by Edge.  A puzzle piece is basically a mapping from one of the four edge indices to an Edge.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"In the solution of a puzzle, each piece should have a unique location in that grid and be in one of four rotations.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"\"\"\"\n    edge_index(::Int)::Int\n\nTurns the argument value into a valid edge index using the modulus\noperator.  This allows us to use aritmetic on edge indices and still\nget a valid index.\n\"\"\"\nedge_index(i::Int) = mod(i, Base.OneTo(4))\n\n\n\"\"\"\n    AbstractPuzzlePiece\n\nAbstractPuzzlePiece is the abstract supertype for all types of jigsaw\npuzzle piece.\n\"\"\"\nabstract type AbstractPuzzlePiece end\n\nedge(piece::AbstractPuzzlePiece, index::Int) =\n    piece.edges[edge_index(index)]\n\n\n\"\"\"\n    perimeter_edge_indices(p::AbstractPuzzlePiece)\n\nReturns a vector of the indices of edges of the puzzle piece `p` that\nare perimeter edges.\n\"\"\"\nfunction perimeter_edge_indices(p::AbstractPuzzlePiece)\n    indices = []\n    for i in 1:length(p.edges)\n        if !ismissing(p.edges[i])\n            if p.edges[i].edge_type.isperimeter\n                push!(indices, i)\n            end\n        end\n    end\n    indices\nend\n\n\n\"\"\"\n    piece_edge(puzzle_piece, index)::Edge\n\nReturns the [`Edge`](@ref) of `puzzle_piece` which corresponds to the\nspecified `edge_index`.\n\"\"\"\nfunction piece_edge(::AbstractPuzzlePiece, index)::Edge\n    error(\"piece_edge has no implementation for AbstractPuzzlePiece.\")\nend","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"When constructing a solved puzzle, it is helpful to fill the grid with puzzle pieces and then assign edges to those pieces to construct a solved puzzle.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"MutablePuzzlePiece is a type piece where the edges can be set.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"\"\"\"\n    MutablePuzzlePiece()\n\nConstructs a `MutablePuzzlePiece` with no edges defined yet.\n\"\"\"\nstruct MutablePuzzlePiece <: AbstractPuzzlePiece\n    edges\n\n    MutablePuzzlePiece() =\n        new(Vector{Union{Missing, Edge}}(missing, 4))\nend","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"Once a puzzle is fully defined, we want to make the pieces immutable. We can make an ImmutablePuzzlePiece for each piece of the newly constructed puzzle.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"Since we have defined a total ordering for Edges, we can identify a puzzle piece by an ordered sequence of its most isless edge and the remaining three edges clockwise from it.","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"function find_least_edge(piece::MutablePuzzlePiece)\n    index_of_least = 1\n    for i in 1:4\n        if edge(piece, i) < edge(piece, index_of_least)\n            index_of_least = i\n        end\n    end\n    index_of_least\nend\n\n\n\"\"\"\n    ImmutablePuzzlePiece(from::MutablePuzzlePiece)\n\nConstructs an `ImmutablePuzzlePiece` from a `MutablePuzzlePiece`.\n\"\"\"\nstruct ImmutablePuzzlePiece <: AbstractPuzzlePiece\n    edges","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"Constructor for testing","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"    function ImmutablePuzzlePiece(edges::Vector{Edge})\n        @assert length(edges) == 4\n        new(sort(edges))\n    end\n\n    function ImmutablePuzzlePiece(from::MutablePuzzlePiece)\n        @assert length(from.edges) == 4\n        @assert all(e -> e isa Edge, from.edges)\n        least = find_least_edge(from)\n        new(tuple(map(i -> edge(from, edge_index(i)),\n                      least : (least + 3))...))\n    end\nend\n\nfunction Base.isless(piece1::ImmutablePuzzlePiece,\n                     piece2::ImmutablePuzzlePiece)\n    function test_index(i)\n        if i > 4\n            return false\n        end\n        if isless(piece1.edges[i],\n                  piece2.edges[i])\n            true\n        elseif piece1.edges[i] == piece2.edges[i]\n            test_index(i + 1)\n        else\n            false\n        end\n    end\n    test_index(1)\nend\n\n\n\"\"\"\n    mating_piece_indices(continuation, piece1::ImmutablePuzzlePiece, piece1::ImmutablePuzzlePiece)\n\nfor each `Edge` of `piece1` that mates with an `Edge` of `piece2,\nCalls `continuation, on the indices into those two pieces of those\nmating edges.\n\"\"\"\nfunction mating_piece_indices(continuation,\n                              piece1::ImmutablePuzzlePiece,\n                              piece2::ImmutablePuzzlePiece)\n    for idx1 in 1:4\n        for idx2 in 1:4\n            if edges_mate(edge(piece1, idx1),\n                          edge(piece2, idx2))","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"Check for borders:","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"                if (edge(piece1, idx1 - 1).edge_type.isperimeter) &&\n                    !(edge(piece2, idx2 + 1).edge_type.isperimeter)\n                    continue\n                end\n                if (edge(piece1, idx1 + 1).edge_type.isperimeter) &&\n                    !(edge(piece2, idx2 - 1).edge_type.isperimeter)\n                    continue\n                end\n                continuation(idx1, idx2)\n            end\n        end\n    end\nend","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"","category":"page"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"EditURL = \"../../src/solved_puzzle.jl\"","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"export SolvedPuzzlePiece, SolvedPuzzle\nexport assign_perimeter_edges, assign_unique_unassigned_edges","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"We can construct a solved puzzle of a specified size by creating puzzle pieces that fit together into a solution.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"In the solution of a puzzle, each piece has a unique location (row and column) and one of four rotations.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"Each edge of a piece, in its solved orientation, can be identified by a cardinal compass direction: n, e, s, or w.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"For two puzzle pieces that share a vertical edge, the piece on the left's E edge will have the same EdgeType as that of the W edge of the piece on the right.  They will have opposite BallOrSockets.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"\"\"\"\n    SolvedPuzzlePiece(row, column)\n\nRepresents the piece of a `SolvedPuzzle` at the specified `row` and\n`column`.\n\nThe `edges` field is a `Dict` which maps from a `CardinalDirection`\nto and [`Edge`](@ref).\n\"\"\"\nstruct SolvedPuzzlePiece\n    row::Int\n    col::Int\n    edges::Dict{CardinalDirection, Edge}\n\n    function SolvedPuzzlePiece(row, col)\n        new(row, col, Dict{CardinalDirection, Edge}())\n    end\nend\n\n\n\"\"\"\n    SolvedPuzzle(rows, columns)\n\nConstructs a `SolvedPuzzle` with the specified numbers of rows and\ncolumns.\n\nThe `grid` field is populated with `SolvedPuzzlePiece`s.\n\"\"\"\nstruct SolvedPuzzle\n    grid\n\n    function SolvedPuzzle(rows::Int, columns::Int)\n        sp = new(Array{SolvedPuzzlePiece, 2}(undef, rows, columns))\n        for r in 1:rows\n            for c in 1:columns\n                sp.grid[r, c] = SolvedPuzzlePiece(r, c)\n            end\n        end\n        sp\n    end\nend","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"It is conventient for SolvedPuzzle to serve as an indexible surrogate for its own grid of puzzle pieces.  We need getindex but not setindex!.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"For out ofbounds indecies we just return nothing rather than throwing an error.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"Base.size(sp::SolvedPuzzle) = size(sp.grid)\n\nBase.IndexStyle(sp::SolvedPuzzle) = IndexCartesian()\n\nfunction Base.getindex(sp::SolvedPuzzle, row::Int, col::Int)\n    (rows, cols) = size(sp)\n    if row < 1 || row > rows || col < 1 || col > cols\n        return nothing\n    end\n    sp.grid[row, col]\nend","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"We randomize the order of the EdgeTypes so they don't hint at the solution.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"\"\"\"\n    random_edge_types(count, is_perimeter)\n\nCreate the specified number of unique [`EdgeType`](@ref)s\nand returns them in a random order.\n\"\"\"\nfunction random_edge_types(count, is_perimeter)\n    edge_types = []\n    for _ in 1:count\n        push!(edge_types, EdgeType(is_perimeter))\n    end\n    shuffle(edge_types)\nend\n\n\n\"\"\"\n    assign_perimeter_edges(SolvedPuzzle)::SolvedPuzzle\n\nAssigns a unique [`EdgeType`](@ref) to the perimeter edge of each of\nthe perimeter puzzle pieces.\n\nThe `SolvedPuzzle` is returned.\n\"\"\"\nfunction assign_perimeter_edges(sp::SolvedPuzzle)::SolvedPuzzle\n    (rows, cols) = size(sp)\n    # We randomize the order of the EdgeTypes so they don't hint at\n    # the solution.\n    edge_types = random_edge_types(2 * rows + 2 * cols, true)\n    for r in 1:rows\n        # Top and bottom edges:\n        sp.grid[r, 1].edges[W()] = Edge(pop!(edge_types), Ball())\n        sp.grid[r, cols].edges[E()] = Edge(pop!(edge_types), Ball())\n    end\n    for c in 1:cols\n        # Left and right edges:\n        sp.grid[1, c].edges[N()] = Edge(pop!(edge_types), Ball())\n        sp.grid[rows, c].edges[S()] = Edge(pop!(edge_types), Ball())\n    end\n    sp\nend\n\n\n\"\"\"\n    assign_unique_unassigned_edges(sp::SolvedPuzzle)::SolvedPuzzle\n\nAssigns an [`EdgeType`](@ref)] to each of the *internal* edges of the\npuzzle.\n\nThe `SolvedPuzzle` is returned.\n\"\"\"\nfunction assign_unique_unassigned_edges(sp::SolvedPuzzle)::SolvedPuzzle\n    (rows, cols) = size(sp)","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"It's ok to create too many EdgeTypes, they're cheap:","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"    edge_types = random_edge_types(4 * rows * cols / 2, false)\n    for r in 1:rows\n        for c in 1:cols\n            do_cardinal_directions(; randomize=true) do direction\n                piece = sp[r, c]\n                if !haskey(piece.edges, direction)\n                    # Edge not yet assigned\n                    new_edge_type = pop!(edge_types)\n                    neignbor =\n                        sp[direction(piece.row, piece.col)...]\n                    # Maybe we should randomize which BallOrSocket to\n                    # use, but why bother?\n                    piece.edges[direction] = Edge(new_edge_type, Ball())\n                    if neignbor != nothing\n                        neignbor.edges[opposite(direction)] =\n                            Edge(new_edge_type, Socket())\n                    end\n                end\n            end\n        end\n    end\n    sp\nend","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MattParkerJigsawPuzzleProblem","category":"page"},{"location":"#MattParkerJigsawPuzzleProblem","page":"Home","title":"MattParkerJigsawPuzzleProblem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MattParkerJigsawPuzzleProblem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this YouTube video Matt Parker asks for a program to help design and solve jigsaw puzzles.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The idea is to produce a set of jigsaw puzzle pieces where the pieces can be assembled in more than one way, and, ideally, in exactly two ways.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is an attempt at that.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Descriptions","page":"Home","title":"Descriptions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [MattParkerJigsawPuzzleProblem]","category":"page"},{"location":"#MattParkerJigsawPuzzleProblem.ALL_EDGE_TYPES","page":"Home","title":"MattParkerJigsawPuzzleProblem.ALL_EDGE_TYPES","text":"ALL_EDGE_TYPES\n\nALL_EDGE_TYPES is a vector of all of the EdgeTypes that have been created.\n\n\n\n\n\n","category":"constant"},{"location":"#MattParkerJigsawPuzzleProblem.AbstractPuzzlePiece","page":"Home","title":"MattParkerJigsawPuzzleProblem.AbstractPuzzlePiece","text":"AbstractPuzzlePiece\n\nAbstractPuzzlePiece is the abstract supertype for all types of jigsaw puzzle piece.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.Edge","page":"Home","title":"MattParkerJigsawPuzzleProblem.Edge","text":"Edge(::EdgeType, ::BallOrSocket)\n\nEdge represents one edge of a puzzle piece.  It has an edge_type. The bs field indicates whether the edge is a ball or socket.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.EdgeType","page":"Home","title":"MattParkerJigsawPuzzleProblem.EdgeType","text":"EdgeType(isperimeter::Bool)\n\nCreates a unique EdgeType.\n\nisperimeter indicates if the EdgeType is for an edge on the perimeter of the puzzle.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.GridCell","page":"Home","title":"MattParkerJigsawPuzzleProblem.GridCell","text":"GridCell(::AbstractPuzzlePiece, rotation::Int)\n\nA GridCell is the container for a puzzle piece in a puzzle grid.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.ImmutablePuzzlePiece","page":"Home","title":"MattParkerJigsawPuzzleProblem.ImmutablePuzzlePiece","text":"ImmutablePuzzlePiece(from::MutablePuzzlePiece)\n\nConstructs an ImmutablePuzzlePiece from a MutablePuzzlePiece.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.MutablePuzzlePiece","page":"Home","title":"MattParkerJigsawPuzzleProblem.MutablePuzzlePiece","text":"MutablePuzzlePiece()\n\nConstructs a MutablePuzzlePiece with no edges defined yet.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.cardinal_directions_from-Tuple{CardinalDirection}","page":"Home","title":"MattParkerJigsawPuzzleProblem.cardinal_directions_from","text":"cardinal_directions_from(d::CardinalDirection)\n\nReturns the four caerdinal directions, starting with d, in next order.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.do_cardinal_directions-Tuple{Any}","page":"Home","title":"MattParkerJigsawPuzzleProblem.do_cardinal_directions","text":"do_cardinal_directions(f; randomize=false)\n\nApplies the function f to each of the four CardinalDirections.\n\nIf randomize is true then the directions are considered in random order.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.edge_direction-Tuple{Int64, Int64}","page":"Home","title":"MattParkerJigsawPuzzleProblem.edge_direction","text":"edge_direction(rotation::Int, index::Int)::CardinalDirection\n\nFor the specified edge_index and rotation of a puzzle piece, return the CardinalDirection that that edge faces.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.edge_index-Tuple{Int64}","page":"Home","title":"MattParkerJigsawPuzzleProblem.edge_index","text":"edge_index(::Int)::Int\n\nTurns the argument value into a valid edge index using the modulus operator.  This allows us to use aritmetic on edge indices and still get a valid index.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.edges_mate-Tuple{Edge, Edge}","page":"Home","title":"MattParkerJigsawPuzzleProblem.edges_mate","text":"edges_mate(::Edge, ::Edge)::Bool\n\nTwo Edges mate if they have the same EdgeType and their bss are opposites.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.fit_piece-Tuple{Any, Matrix{Union{Missing, GridCell}}, Int64, Int64, ImmutablePuzzlePiece}","page":"Home","title":"MattParkerJigsawPuzzleProblem.fit_piece","text":"fit_piece(continuation, grid::Grid, row::Int, col::Int,\n               piece::ImmutablePuzzlePiece)\n\nAttempts to fit piece into the specified location of grid. continuation is called for each rotation of piece that fits.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.get_neighboring_edge-Tuple{Matrix{Union{Missing, GridCell}}, Int64, Int64, CardinalDirection}","page":"Home","title":"MattParkerJigsawPuzzleProblem.get_neighboring_edge","text":"getneighboringedge(grid::Grid, row::Int, col::Int, direction::CardinalDirection) \n\nReturns the Edge of the \"neighboring cell\" to the specified grid location.  If that location is out of bounds then Edge(EdgeType(true, 0), Straight()) is returned.  Otherwise, if there is no GridCell at the specified location yet, then missing is returned.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.mating_piece_indices-Tuple{Any, ImmutablePuzzlePiece, ImmutablePuzzlePiece}","page":"Home","title":"MattParkerJigsawPuzzleProblem.mating_piece_indices","text":"mating_piece_indices(continuation, piece1::ImmutablePuzzlePiece, piece1::ImmutablePuzzlePiece)\n\nfor each Edge of piece1 that mates with an Edge of piece2, Callscontinuation, on the indices into those two pieces of those mating edges.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.new_grid-Tuple{Any, Any}","page":"Home","title":"MattParkerJigsawPuzzleProblem.new_grid","text":"new_grid(number_of_rows, number_of_columns)::Grid\n\nCreates an empty puzzle grid of the specified dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.next-Tuple{N}","page":"Home","title":"MattParkerJigsawPuzzleProblem.next","text":"next(::CardinalDirection)::CardinalDirection\n\nReturns the next direction clockwise from the given direction.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.opposite-Tuple{N}","page":"Home","title":"MattParkerJigsawPuzzleProblem.opposite","text":"opposite(::CardinalDirection)::CardinalDirection\n\nReturns the opposite direction.  N() and S() are opposites. E() and W() are opposites.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.perimeter_edge_indices-Tuple{AbstractPuzzlePiece}","page":"Home","title":"MattParkerJigsawPuzzleProblem.perimeter_edge_indices","text":"perimeter_edge_indices(p::AbstractPuzzlePiece)\n\nReturns a vector of the indices of edges of the puzzle piece p that are perimeter edges.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.perimeter_edge_indices-Tuple{Matrix{Union{Missing, GridCell}}, Int64, Int64}","page":"Home","title":"MattParkerJigsawPuzzleProblem.perimeter_edge_indices","text":"perimeter_edge_indices(grid::Grid, row::int, col::Int)\n\nReturns a vector of the indices of edges of the specified cell of grid that are perimeter edges.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.perimeters-Tuple{MultipleSolutionPuzzle, Int64, Int64}","page":"Home","title":"MattParkerJigsawPuzzleProblem.perimeters","text":"perimeters(puzzle::MultipleSolutionPuzzle, row::Int, col::Int)\n\nReturns a four element vector indicating for each direction (N, E, S, W) whether that side of the cell at row, col is a perimeter of the puzzle.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.piece_edge-Tuple{AbstractPuzzlePiece, Any}","page":"Home","title":"MattParkerJigsawPuzzleProblem.piece_edge","text":"piece_edge(puzzle_piece, index)::Edge\n\nReturns the Edge of puzzle_piece which corresponds to the specified edge_index.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.previous-Tuple{N}","page":"Home","title":"MattParkerJigsawPuzzleProblem.previous","text":"previous(::CardinalDirection)::CardinalDirection\n\nReturns the previous direction, that which is counter-clockwise, from the given direction.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.puzzle_pieces-Tuple{MultipleSolutionPuzzle}","page":"Home","title":"MattParkerJigsawPuzzleProblem.puzzle_pieces","text":"puzzle_pieces(puzzle::MultipleSolutionPuzzle)::Vector{MutablePuzzlePiece}\n\nReturns a vector of all of the MutablePuzzlePieces of puzzle.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.rotation-Tuple{Int64}","page":"Home","title":"MattParkerJigsawPuzzleProblem.rotation","text":"rotation(rot::Int)\n\nNormalizes the rotation of the placement of a puzzle piece to one of 0, 1, 2, or 3.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.terserep-Tuple{MultipleSolutionPuzzle}","page":"Home","title":"MattParkerJigsawPuzzleProblem.terserep","text":"terserep(puzzle)\n\nOutput a terse printed representation of the puzzle.\n\n\n\n\n\n","category":"method"},{"location":"grid_html/","page":"-","title":"-","text":"EditURL = \"../../src/grid_html.jl\"","category":"page"},{"location":"grid_html/","page":"-","title":"-","text":"import XML\nusing XML: Element\n\nexport writing_html_file, html_wrapper, grid_to_html","category":"page"},{"location":"grid_html/","page":"-","title":"-","text":"We need an easy to understand representation of a puzze.  HEre we generate an HTML table from a puzzle grid.","category":"page"},{"location":"grid_html/","page":"-","title":"-","text":"GRID_STYESHEET = \"\"\"\n\n.grid {\n    display: block;\n    margin: 2ex;\n    padding: 2ex;\n    border: solid yellow;\n}\n.GridCell {\n    display: block;\n    margin: 0;\n    padding: 2;\n    border: solid yellow;\n}\n.Edge {\n    font-family: sans-serif;\n}\n.Edge.N {\n    display: block;\n    vertical-align: top;\n    text-align: center;\n}\n.Edge.E {\n    display: inline-block;\n    margin-left: 1em;\n    vertical-align: center;\n    text-align: end;\n}\n.Edge.S {\n    display: block;\n    vertical-align: bottom;\n    text-align: center;\n}\n.Edge.W {\n    display: inline-block;\n    margin-right: 1em;\n    vertical-align: center;\n    text-align: start;\n}\n\"\"\"\n\nfunction writing_html_file(body, filename)\n    # body should return a vector of HTML Elements.\n    XML.write(filename,\n              html_wrapper(body());\n              indentsize=2)\nend\n\nfunction html_wrapper(body_elements)\n    Element(\n        \"html\",\n        Element(\n            \"head\",\n            Element(\"style\", GRID_STYESHEET)),\n        Element(\n            \"body\", body_elements...)\n    )\nend\n\n\nfunction grid_to_html(grid::Grid)\n    (nrows, ncols) = size(grid)\n    Element(\n        \"div\",\n        Element(\n            \"table\",\n            [ Element(\n                \"tr\",\n                [\n                    Element(\n                        \"td\",\n                        Element(\n                            \"div\",\n                            let\n                                cell = grid[row, col]\n                                if cell isa GridCell\n                                    edges = []\n                                    for d in [N(), W(), E(), S()]\n                                        edge = get_edge(cell, d)\n                                        # Maybe do something to highlight\n                                        # mismatched edges.\n                                        push!(edges,\n                                              Element(\n                                                  \"div\",\n                                                  terserep(edge);\n                                                  class=\"Edge $(string(typeof(d)))\"))\n                                    end\n                                    edges\n                                else\n                                    [ \"&nbsp\" ]\n                                end\n                            end...;\n                            class=\"GridCell\")\n                    )\n                    for col in 1:ncols\n                        ]...\n                            )\n              for row in 1:nrows ]...);\n    class=\"grid\")\nend","category":"page"},{"location":"grid_html/","page":"-","title":"-","text":"","category":"page"},{"location":"grid_html/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"EditURL = \"../../src/edges.jl\"","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"export ALL_EDGE_TYPES, EdgeType\nexport BallOrSocket, Ball, Socket, Straight\nexport opposite, Edge, isperimeter, edges_mate","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We define some number of \"edge types\".  If the puzzle pieces are all square, then there is only one edge type.  If they are rectangular then there are two edge types: one for each edge length.  Each different shape of interlocking edge represents another edge type.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"MORE PRACTICALLY THOUGH: since we don't want to match two puzzle pieces on a flat perimeter edge, each edge on the perimeter of the puzzle should have a different edge type.  For a 3 by 5 puzzle, that gives 16 edge types before you start defining edge types for the internal edges.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We define EdgeType and create an instance for each distinct edge type. All an EdgeType needs is uniqueness.  It might be handy to note if the EdgeType represents a perimeter edge though, so we track that.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We accumulate a catalog of every EdgeType in ALL_EDGE_TYPES.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"\"\"\"\n    ALL_EDGE_TYPES\n\n`ALL_EDGE_TYPES` is a vector of all of the `EdgeType`s that have been\ncreated.\n\"\"\"\nALL_EDGE_TYPES = []\n\nlet\n    NEXT_EDGE_UID = 1\n\n    struct EdgeType\n        isperimeter::Bool\n        uid::Int\n\n        # For testing:\n        EdgeType(isperimeter, uid) = new(isperimeter, uid)\n\n        function EdgeType(isperimeter)\n            et = new(isperimeter,\n                     let\n                         uid = NEXT_EDGE_UID\n                         NEXT_EDGE_UID += 1\n                         uid\n                     end)\n            push!(ALL_EDGE_TYPES, et)\n            return et\n        end\n    end\nend\n\n@doc \"\"\"\n    EdgeType(isperimeter::Bool)\n\nCreates a unique `EdgeType`.\n\n`isperimeter` indicates if the EdgeType is for an edge on the\nperimeter of the puzzle.\n\"\"\" EdgeType\n\n\nisperimeter(e::EdgeType) = e.isperimeter","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"At the edge where two puzzle pieces interlock, the edges of those pieces are mirror images of each other.  At that meeting edge, one piece has a ball and the other has a socket.  If the edge is at the border of the puzzle then it is straight.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"The edge of a puzzle piece is thus characterized by its EdgeType and whether it is a ball, socket, or straight.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"Ball and Socket are opposites.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"Straight is its own opposite.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"abstract type BallOrSocket end\nstruct Ball <: BallOrSocket end\nstruct Socket <: BallOrSocket end\nstruct Straight <: BallOrSocket end\n\nopposite(::Ball) = Socket()\nopposite(::Socket) = Ball()\nopposite(::Straight) = Straight()\n\n\n\"\"\"\n    Edge(::EdgeType, ::BallOrSocket)\n\n`Edge` represents one edge of a puzzle piece.  It has an `edge_type`.\nThe `bs` field indicates whether the edge is a *ball* or *socket*.\n\n\"\"\"\nstruct Edge\n    edge_type::EdgeType\n    bs::BallOrSocket\nend\n\nisperimeter(e::Edge) = isperimeter(e.edge_type)\nisperimeter(::Missing) = false\n\nopposite(edge::Edge) = Edge(edge.edge_type, opposite(edge.bs))","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"It is easier to index things if there is a total ordering defined for them.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"EdgeTypes can be ordered by their uid.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We arbitrarily decide that Ball comes before Socket.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We can then define a total ordering on Edges.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"function Base.isless(a::EdgeType, b::EdgeType)::Bool\n    a.uid < b.uid\nend\n\nfunction Base.isless(a::BallOrSocket, b::BallOrSocket)\n    false\nend\n\nfunction Base.isless(::Ball, ::Socket)\n    true\nend\n\nfunction Base.isless(a::Edge, b::Edge)\n    (isless(a.edge_type, b.edge_type) ||\n        (a.edge_type == b.edge_type &&\n        isless(a.bs, b.bs)))\nend","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"Two Edges match if they have the same EdgeType and their bss are opposites.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"\"\"\"\n    edges_mate(::Edge, ::Edge)::Bool\n\nTwo `Edge`s mate if they have the same `EdgeType` and their `bs`s are\nopposites.\n\"\"\"\nfunction edges_mate(e1::Edge, e2::Edge)::Bool","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"For perimeter edges the EdgeType doesn't matter:","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"    (e1.bs == e2.bs == Straight()) ||\n        ((e1.edge_type == e2.edge_type) &&\n        (opposite(e1.bs) == e2.bs))\nend","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"This page was generated using Literate.jl.","category":"page"}]
}
