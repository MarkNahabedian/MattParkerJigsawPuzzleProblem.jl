var documenterSearchIndex = {"docs":
[{"location":"terse_representation/","page":"-","title":"-","text":"using Printf\n\nexport terserep\n\nTo help with debugging, we define a more terse representation of edges, puzzle pieces and grids.\n\nterserep(et::EdgeType) = @sprintf(\"%d\", et.uid)\n\nterserep(::Ball) = \"b\"\nterserep(::Socket) = \"s\"\nterserep(::Straight) = \"_\"\n\nterserep(::Nothing) = \"?\"\n\nterserep(edge::Edge) =\n    @sprintf(\"%s%s\",\n             terserep(edge.edge_type),\n             terserep(edge.bs))\n\nterserep(piece::AbstractPuzzlePiece) =\n    join(terserep.(piece.edges), \"/\")\n\nterserep(cell::GridCell) =\n    join(terserep.([ get_edge(cell, direction)\n                     for direction in CARDINAL_DIRECTIONS ]),\n         \"/\")\n\nterserep(::Missing) = \"#\"\n\nfunction terserep(grid::Grid)\n    (nrows, ncols) = size(grid)\n    for r in 1:nrows\n        for c in 1:ncols\n            print(terserep(grid[r, c]), \"\\t\")\n        end\n        println()\n    end\nend\n\n\n\n\"\"\"\n    terserep(puzzle)\n\nOutput a terse printed representation of the puzzle.\n\"\"\"\nfunction terserep(puzzle::MultipleSolutionPuzzle)\n    for grid in puzzle.grids\n        terserep(grid)\n        println()\n    end\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"multiple_solutions/","page":"Constructing a Puzzle","title":"Constructing a Puzzle","text":"export MultipleSolutionPuzzle, perimeters, puzzle_pieces\n\nMatt Parker's YouTube video is about jigsaw puzzles that have more than one solution.  Here we attempt to construct such a puzzle by makiing one grid for each solution and placiing the same set of MutablePuzzlePieces, with different locations and orientations, in each grid.\n\n\"\"\"\n    MultipleSolutionPuzzle(number_of_rows, number_of_columns, number_of_grids)\n\nMultipleSolutionPuzzle is used to generate jigsaw puzzles with the\nspecified numnber of rows and colukmns.  It will attempy to generate\n`number_of_grids` puzzles with the same pieces.  The pieces that are\ngenerated can be assembled least that number of of different ways.\nOne must run the solver to see how many ways the pieces can actually\nbe assembled.\n\nUse [`puzzle_pieces`](@ref) to get the pieces.\n\"\"\"\nstruct MultipleSolutionPuzzle\n    grids\n\n    # It's simpler to populate the first grid with Pieces that have\n    # no edges yet, add the perimeter edges and then permute them for\n    # the other grids.\n    function MultipleSolutionPuzzle(number_of_rows, number_of_columns,\n                                    number_of_grids)\n        puzzle = new(map(_ -> new_grid(number_of_rows, number_of_columns),\n                         1:number_of_grids))\n        # Populate the first grid and set its perimeter edges:\n        grid1 = puzzle.grids[1]\n        corners = []\n        edges = []\n        middle = []\n        for r in 1:number_of_rows\n            for c in 1:number_of_columns\n                piece = MutablePuzzlePiece()\n                cell = GridCell(r, c, piece, rand(0:3))\n                grid1[r, c] = cell\n                perimeter_count = 0\n                if r == 1\n                    set_edge!(cell, N(), Edge(EdgeType(true), Straight()))\n                    perimeter_count += 1\n                elseif r == number_of_rows\n                    set_edge!(cell, S(), Edge(EdgeType(true), Straight()))\n                    perimeter_count += 1\n                end\n                if c == 1\n                    set_edge!(cell, W(), Edge(EdgeType(true), Straight()))\n                    perimeter_count += 1\n                elseif c == number_of_columns\n                    set_edge!(cell, E(), Edge(EdgeType(true), Straight()))\n                    perimeter_count += 1\n                end\n                if perimeter_count == 2\n                    push!(corners, piece)\n                elseif perimeter_count == 1\n                    push!(edges, piece)\n                elseif perimeter_count == 0\n                    push!(middle, piece)\n                else\n                    error(\"Puzzle is too small\")\n                end\n            end\n        end\n        # Once we permute the corner or edge pieces of a puzzle for\n        # other grids, they won't end up in the same locations so\n        # might need to be rotated of thealternate locations.\n        # Compute the rotation for the cell such that the perimeter\n        # edges of the piece match those of the cell.\n        function cell_rotation(row, col, piece::MutablePuzzlePiece)\n            count_perimeters(pmtrs) = sum(p -> p == true, pmtrs)\n            cell_perimeters = perimeters(puzzle, row, col)\n            for rot in 0:3\n                piece_perimeters =\n                    [ isperimeter(piece.edges[i])\n                      for i in edge_index.((1:4) .+ rot) ]\n                @assert count_perimeters(cell_perimeters) ==\n                    count_perimeters(piece_perimeters)\n                if cell_perimeters == piece_perimeters\n                    return rot\n                end\n            end\n            @assert false \"Can't determine piece rotation.\"\n        end\n        # Populate the remaining grids with permutations of the\n        # pieces from grid1:\n        for i in 2:number_of_grids\n            grid = puzzle.grids[i]\n            permuted_corners = Random.shuffle(corners)\n            permuted_edges = Random.shuffle(edges)\n            permuted_middle = Random.shuffle(middle)\n            for r in 1:number_of_rows\n                for c in 1:number_of_columns\n                    if r in [1, number_of_rows] && c in [1, number_of_columns]\n                        piece = pop!(permuted_corners)\n                    elseif (r in [1, number_of_rows] ||\n                        c in [1, number_of_columns])\n                        piece = pop!(permuted_edges)\n                    else\n                        piece = pop!(permuted_middle)\n                    end\n                    rotation = cell_rotation(r, c, piece)\n                    grid[r, c] = GridCell(r, c, piece, rotation)\n                end\n            end\n        end\n        # Make sure every piece is in every grid exactly once:\n        let\n            all_pieces = Set([corners..., edges..., middle...])\n            for grid in puzzle.grids\n                grid_pieces = Set()\n                for r in 1:number_of_rows\n                    for c in 1:number_of_columns\n                        push!(grid_pieces, grid[r, c].puzzle_piece)\n                    end\n                end\n                @assert all_pieces == grid_pieces\n            end\n        end\n\nAssign edges to every puzzle piece\n\n        function propagate_edge(edge::Edge, piece::MutablePuzzlePiece)\n            # edge is the one that was just set in piece.\n            # Propagate to the neighboring piece in each grid.\n            for gridi in 1:length(puzzle.grids)\n                grid = puzzle.grids[gridi]\n                cell = grid[findfirst(grid) do cell\n                                cell.puzzle_piece == piece\n                            end]\n                direction = direction_for_edge(cell, edge)\n                neighbor = direction(grid, cell)\n                @assert isa(neighbor, GridCell)\n                neighbor_edge = get_edge(neighbor, opposite(direction))\n                if !isa(neighbor_edge, Edge)\n                    neighbor_edge = opposite(edge)\n                    set_edge!(neighbor, opposite(direction),\n                              neighbor_edge)\n                    propagate_edge(neighbor_edge, neighbor.puzzle_piece)\n                else\n                    # Neighbor already has an Edge facing us, so make\n                    # sure it matches:\n                    if !edges_mate(edge, neighbor_edge)\n                        writing_html_file(\"edges_do_not_mate.html\") do\n                            grids_to_html(puzzle.grids)\n                        end\n                        error(\"Edges don't mate: $gridi $cell\\n$edge\\n$neighbor_edge\\n\")\n                    end\n                end\n            end\n        end\n        # Fill in the missing edges of grid1 and propagate the new\n        # edges:\n        for r in 1:number_of_rows\n            for c in 1:number_of_columns\n                for direction in CARDINAL_DIRECTIONS\n                    cell = grid1[r, c]\n                    if ismissing(get_edge(cell, direction))\n                        new_edge = Edge(EdgeType(false),\n                                        (Ball(), Socket())[rand(1:2)])\n                        set_edge!(cell, direction, new_edge)\n                        propagate_edge(new_edge, cell.puzzle_piece)\n                    end\n                end\n            end\n        end\n        # Make sure every cell has a puzzle piece with all four edges:\n        for g in 1:length(puzzle.grids)\n            grid = puzzle.grids[g]\n            for r in 1:number_of_rows\n                for c in 1:number_of_columns\n                    cell = grid[r, c]\n                    @assert(cell.puzzle_piece isa MutablePuzzlePiece,\n                            \"grid $g, cell $r $c is not a puzzle piece\")\n                    for direction in CARDINAL_DIRECTIONS\n                        @assert(!ismissing(get_edge(cell, direction)),\n                                \"grid, $g cell $r $c has no edge for $direction\")\n                    end\n                end\n            end\n        end\n        puzzle\n    end\nend\n\n\nBase.size(puzzle::MultipleSolutionPuzzle) = size(puzzle.grids[1])\n\n\n\"\"\"\n    perimeters(puzzle::MultipleSolutionPuzzle, row::Int, col::Int)\n\nReturns a four element vector indicating for each direction (N, E, S,\nW) whether that side of the cell at `row`, `col` is a perimeter of the\npuzzle.\n\"\"\"\nfunction perimeters(puzzle::MultipleSolutionPuzzle, row::Int, col::Int)\n    (nrows, ncols) = size(puzzle)\n    [\n        row == 1,\n        col == ncols,\n        row == nrows,\n        col == 1\n    ]\nend\n\n\nfunction check_puzzle(puzzle::MultipleSolutionPuzzle)\n    errors = []\n    (nrows, ncols) = size(puzzle)\n    for gridi in 1:length(puzzle.grids)\n        grid = puzzle.grids[gridi]\n        for r in 1:nrows\n            for c in 1:ncols\n                for d in [N(), E()]\n                    cell = grid[r, c]\n                    neighbor = d(grid, cell)\n                    cell_edge = get_edge(cell, d)\n                    neighbor_edge = get_edge(neighbor, opposite(d))\n                    if !edges_mate(cell_edge, neighbor_edge)\n                        push!(errors,\n                              \"$gridi $r $c $d: $cell_edge $neighbor_edge\")\n                    end\n                end\n            end\n        end\n    end\n    return isempty(erros), errors\nend\n\n\n\"\"\"\n    puzzle_pieces(puzzle::MultipleSolutionPuzzle)::Vector{MutablePuzzlePiece}\n\nReturns a vector of all of the `MutablePuzzlePiece`s of `puzzle`.\n\"\"\"\nfunction puzzle_pieces(puzzle::MultipleSolutionPuzzle)\n    pieces = []\n    for cell in puzzle.grids[1]\n        push!(pieces, cell.puzzle_piece)\n    end\n    pieces\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"module MattParkerJigsawPuzzleProblem\n\nusing DataStructures\nusing InteractiveUtils\nusing Literate\nusing Markdown\nusing Random\n\ninclude(\"edges.jl\")\ninclude(\"puzzle_pieces.jl\")\ninclude(\"grid.jl\")\ninclude(\"multiple_solutions.jl\")\ninclude(\"terse_representation.jl\")\ninclude(\"grid_html.jl\")\ninclude(\"solver.jl\")\n\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"grid/","page":"Grid","title":"Grid","text":"export CardinalDirection, N, E, S, W, CARDINAL_DIRECTIONS\nexport opposite\nexport rotation, GridCell\nexport get_edge, set_edge!, direction_for_edge\nexport Grid, new_grid, get_neighboring_edge, fit_piece\n\nPuzzle pieces are assembled into a grid when the puzzle is being put together.  That grid has some number of rows and columns.  For a given row and column the grid has a cell which can be associated with the puzzle piece that belongs there.\n\nThe grid has three kinds of cells: corner, edge, and middle.  If a grid has R rows and C columns, it will have R × C cells. No matter the size of the grid, it will have 4 corner cells.  The number of edge cells is 2 × (R - 2) + 2 * (C - 2).  The remaining (R - 2) × (C - 2) cells are middle cells.\n\nEach cell has four neighbors, one in each of the cardinal compass directions.\n\n\"\"\"\n    GridCell(::AbstractPuzzlePiece, rotation::Int)\n\nA GridCell is the container for a puzzle piece in a puzzle grid.\n\"\"\"\nstruct GridCell\n    row::Int\n    col::Int\n    puzzle_piece\n    rotation::Int\n\n    GridCell(row, col, piece, rotation) =\n        new(row, col, piece, mod(rotation, 4))\nend\n\nImmutablePuzzlePiece(cell::GridCell) =\n    ImmutablePuzzlePiece(cell.puzzle_piece)\n\n\nconst Grid = Array{Union{Missing, GridCell}, 2}\n\n\"\"\"\n    new_grid(number_of_rows, number_of_columns)::Grid\n\nCreates an empty puzzle grid of the specified dimensions.\n\"\"\"\nnew_grid(number_of_rows, number_of_columns)::Grid =\n    Grid(missing, number_of_rows, number_of_columns)\n\n\nabstract type CardinalDirection end\nstruct N <: CardinalDirection end\nstruct E <: CardinalDirection end\nstruct S <: CardinalDirection end\nstruct W <: CardinalDirection end\n\nconst CARDINAL_DIRECTIONS = (N(), E(), S(), W())\n\n\n\"\"\"\n    opposite(::CardinalDirection)::CardinalDirection\n\nReturns the opposite direction.  `N()` and `S()` are opposites.\n`E()` and `W()` are opposites.\n\"\"\"\nopposite(::N) = S()\nopposite(::E) = W()\nopposite(::S) = N()\nopposite(::W) = E()\n\nedge_index(::N) = 1\nedge_index(::E) = 2\nedge_index(::S) = 3\nedge_index(::W) = 4\n\nStarting from a given CardinalDirection, we can identify a sequence of all of the CardinalDirections in clockwise order.\n\nGiven the row and column indices of a grid cell, and a CardinalDirection, we can compute the coordinates of the neighboring cell in that direction.\n\nEach instance of a CardinalDirection serves as an operator for going from one pair of row/coumn indices to the neighboring ones in that direction.  As these operators don't know the size of the grid, bounds checking must be done by their callers.\n\n(::N)(row::Int, col::Int) = [row - 1, col]\n(::E)(row::Int, col::Int) = [row,     col + 1]\n(::S)(row::Int, col::Int) = [row + 1, col]\n(::W)(row::Int, col::Int) = [row,     col - 1]\n\nWhich edge of a puzzle piece is facing a given CardinalDirection depends on the rotation of that piece.\n\nThe rotation of a puzzle piece is represented by one of the integers 0, 1, 2, or 3, also in clockwise order.\n\n\"\"\"\n    rotation(rot::Int)\n\nNormalizes the rotation of the placement of a puzzle piece to one of\n0, 1, 2, or 3.\n\"\"\"\nrotation(r::Int) = mod(r, 4)\n\nWithin a grid, a GridCell has a neighbor in each direction.\n\n(cd::CardinalDirection)(gc::GridCell) = cd(gc.row, gc.col)\n\nfunction (cd::CardinalDirection)(grid::Grid, row::Int, col::Int)\n    (r, c) = cd(row, col)\n    (nrows, ncols) = size(grid)\n    if !(r in 1:nrows) || !(c in 1:ncols)\n        return missing\n    end\n    return grid[r, c]\nend\n\n(cd::CardinalDirection)(grid::Grid, cell::GridCell) =\n    cd(grid, cell.row, cell.col)\n\n\nfunction get_edge(gc::GridCell, direction::CardinalDirection)\n    i = edge_index(edge_index(direction) + gc.rotation)\n    gc.puzzle_piece.edges[i]\nend\n\nfunction set_edge!(gc::GridCell, direction::CardinalDirection,\n                   edge::Edge)\n    i = edge_index(edge_index(direction) + gc.rotation)\n    gc.puzzle_piece.edges[i] = edge\nend\n\nisperimeter(cell::GridCell, direction::CardinalDirection) =\n    isperimeter(get_edge(cell, direction))\n\nfunction direction_for_edge(cell::GridCell, edge::Edge)\n    for d in CARDINAL_DIRECTIONS\n        e = get_edge(cell, d)\n        if e isa Edge\n            if e == edge\n                return d\n            end\n        end\n    end\n    return missing\nend\n\n\n\"\"\"\n    perimeter_edge_indices(grid::Grid, row::int, col::Int)\n\nReturns a vector of the indices of edges of the specified cell of\n`grid` that are perimeter edges.\n\"\"\"\nfunction perimeter_edge_indices(grid::Grid, row::Int, col::Int)\n    indices = []\n    (nrows, ncols) = size(grid)\n    if row == 1;      push!(indices, 1); end\n    if col == ncols;  push!(indices, 2); end\n    if row == nrows;  push!(indices, 3); end\n    if col == 1;      push!(indices, 4); end\n    indices\nend\n\n\"\"\"\n   get_neighboring_edge(grid::Grid, row::Int, col::Int, direction::CardinalDirection)\n\nReturns the `Edge` of the \"neighboring cell\" to the specified grid\nlocation.  If that location is out of bounds then `Edge(EdgeType(true,\n0), Straight())` is returned.  Otherwise, if there is no GridCell at\nthe specified location yet, then `missing` is returned.\n\"\"\"\nfunction get_neighboring_edge(grid::Grid, row::Int, col::Int,\n                              direction::CardinalDirection)\n    (nrows, ncols) = size(grid)\n    neighbor_indices = direction(row, col)\n    if (neighbor_indices[1] < 1 ||\n        neighbor_indices[1] > nrows ||\n        neighbor_indices[2] < 1 ||\n        neighbor_indices[2] > ncols\n        )\n        return Edge(EdgeType(true, 0), Straight())\n    else\n        cell = grid[neighbor_indices...]\n        if cell isa GridCell\n            return get_edge(cell, opposite(direction))\n        end\n    end\n    return missing\nend\n\n\n\"\"\"\n    fit_piece(continuation, grid::Grid, row::Int, col::Int,\n                   piece::ImmutablePuzzlePiece)\n\nAttempts to fit `piece` into the specified location of `grid`.\n`continuation` is called for each rotation of `piece` that fits.\n\"\"\"\nfunction fit_piece(continuation, grid::Grid, row::Int, col::Int,\n                   piece::ImmutablePuzzlePiece)\n    # If the piece fits at the specified location in grid, call\n    # continuation with the rotation of the piece.\n    for rot in 0:3\n        for d in CARDINAL_DIRECTIONS\n            piece_edge = piece.edges[edge_index(rot + edge_index(d))]\n            neighbor_edge = get_neighboring_edge(grid, row, col, d)\n            if ismissing(neighbor_edge)\n                continue\n            end\n            if !edges_mate(piece_edge, neighbor_edge)\n                @goto no_fit\n            end\n        end\n        continuation(rot)\n        @label no_fit\n    end\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"puzzle_pieces/","page":"PuzzlePieces","title":"PuzzlePieces","text":"export edge_index\nexport AbstractPuzzlePiece, perimeter_edge_indices\nexport MutablePuzzlePiece, ImmutablePuzzlePiece\nexport mating_piece_indices\n\nA jigsaw puzzle is constructed as a two dimensional grid of pieces.\n\nEach piece has four edges, which we can identify using the small positive integers 1, 2, 3, and 4 (edge indices), which identify the piece's edges in clockwise order.  An edge is modeled by Edge.  A puzzle piece is basically a mapping from one of the four edge indices to an Edge.\n\nIn the solution of a puzzle, each piece should have a unique location in that grid and be in one of four rotations.\n\n\"\"\"\n    edge_index(::Int)::Int\n\nTurns the argument value into a valid edge index using the modulus\noperator.  This allows us to use aritmetic on edge indices and still\nget a valid index.\n\"\"\"\nedge_index(i::Int) = mod(i, Base.OneTo(4))\n\n\n\"\"\"\n    AbstractPuzzlePiece\n\nAbstractPuzzlePiece is the abstract supertype for all types of jigsaw\npuzzle piece.\n\"\"\"\nabstract type AbstractPuzzlePiece end\n\nedge(piece::AbstractPuzzlePiece, index::Int) =\n    piece.edges[edge_index(index)]\n\n\n\"\"\"\n    perimeter_edge_indices(p::AbstractPuzzlePiece)\n\nReturns a vector of the indices of edges of the puzzle piece `p` that\nare perimeter edges.\n\"\"\"\nfunction perimeter_edge_indices(p::AbstractPuzzlePiece)\n    indices = []\n    for i in 1:length(p.edges)\n        if !ismissing(p.edges[i])\n            if p.edges[i].edge_type.isperimeter\n                push!(indices, i)\n            end\n        end\n    end\n    indices\nend\n\n\n\"\"\"\n    piece_edge(puzzle_piece, index)::Edge\n\nReturns the [`Edge`](@ref) of `puzzle_piece` which corresponds to the\nspecified `edge_index`.\n\"\"\"\nfunction piece_edge(::AbstractPuzzlePiece, index)::Edge\n    error(\"piece_edge has no implementation for AbstractPuzzlePiece.\")\nend\n\nWhen constructing a solved puzzle, it is helpful to fill the grid with puzzle pieces and then assign edges to those pieces to construct a solved puzzle.\n\nMutablePuzzlePiece is a type piece where the edges can be set.\n\n\"\"\"\n    MutablePuzzlePiece()\n\nConstructs a `MutablePuzzlePiece` with no edges defined yet.\n\"\"\"\nstruct MutablePuzzlePiece <: AbstractPuzzlePiece\n    edges\n\n    MutablePuzzlePiece() =\n        new(Vector{Union{Missing, Edge}}(missing, 4))\nend\n\nOnce a puzzle is fully defined, we want to make the pieces immutable. We can make an ImmutablePuzzlePiece for each piece of the newly constructed puzzle.\n\nSince we have defined a total ordering for Edges, we can identify a puzzle piece by an ordered sequence of its most isless edge and the remaining three edges clockwise from it.\n\nfunction find_least_edge(piece::MutablePuzzlePiece)\n    index_of_least = 1\n    for i in 1:4\n        if edge(piece, i) < edge(piece, index_of_least)\n            index_of_least = i\n        end\n    end\n    index_of_least\nend\n\n\n\"\"\"\n    ImmutablePuzzlePiece(from::MutablePuzzlePiece)\n\nConstructs an `ImmutablePuzzlePiece` from a `MutablePuzzlePiece`.\n\"\"\"\nstruct ImmutablePuzzlePiece <: AbstractPuzzlePiece\n    edges\n\n    # Constructor for testing\n    function ImmutablePuzzlePiece(edges::Vector{Edge})\n        @assert length(edges) == 4\n        new(sort(edges))\n    end\n\n    function ImmutablePuzzlePiece(from::MutablePuzzlePiece)\n        @assert length(from.edges) == 4\n        @assert all(e -> e isa Edge, from.edges)\n        least = find_least_edge(from)\n        new(tuple(map(i -> edge(from, edge_index(i)),\n                      least : (least + 3))...))\n    end\nend\n\nfunction Base.isless(piece1::ImmutablePuzzlePiece,\n                     piece2::ImmutablePuzzlePiece)\n    function test_index(i)\n        if i > 4\n            return false\n        end\n        if isless(piece1.edges[i],\n                  piece2.edges[i])\n            true\n        elseif piece1.edges[i] == piece2.edges[i]\n            test_index(i + 1)\n        else\n            false\n        end\n    end\n    test_index(1)\nend\n\n\n\"\"\"\n    mating_piece_indices(continuation, piece1::ImmutablePuzzlePiece, piece1::ImmutablePuzzlePiece)\n\nfor each `Edge` of `piece1` that mates with an `Edge` of `piece2`,\nCalls `continuation`, on the indices into those two pieces of those\nmating edges.\n\"\"\"\nfunction mating_piece_indices(continuation,\n                              piece1::ImmutablePuzzlePiece,\n                              piece2::ImmutablePuzzlePiece)\n    for idx1 in 1:4\n        for idx2 in 1:4\n            if edges_mate(edge(piece1, idx1),\n                          edge(piece2, idx2))\n                # Check for borders:\n                if (edge(piece1, idx1 - 1).edge_type.isperimeter) &&\n                    !(edge(piece2, idx2 + 1).edge_type.isperimeter)\n                    continue\n                end\n                if (edge(piece1, idx1 + 1).edge_type.isperimeter) &&\n                    !(edge(piece2, idx2 - 1).edge_type.isperimeter)\n                    continue\n                end\n                continuation(idx1, idx2)\n            end\n        end\n    end\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"solved_puzzle/","page":"-","title":"-","text":"export SolvedPuzzlePiece, SolvedPuzzle\nexport assign_perimeter_edges, assign_unique_unassigned_edges\n\nWe can construct a solved puzzle of a specified size by creating puzzle pieces that fit together into a solution.\n\nIn the solution of a puzzle, each piece has a unique location (row and column) and one of four rotations.\n\nEach edge of a piece, in its solved orientation, can be identified by a cardinal compass direction: N, E, S, or W.\n\nFor two puzzle pieces that share a vertical edge, the piece on the left's E edge will have the same EdgeType as that of the W edge of the piece on the right.  They will have opposite BallOrSockets.\n\n\"\"\"\n    SolvedPuzzlePiece(row, column)\n\nRepresents the piece of a `SolvedPuzzle` at the specified `row` and\n`column`.\n\nThe `edges` field is a `Dict` which maps from a `CardinalDirection`\nto and [`Edge`](@ref).\n\"\"\"\nstruct SolvedPuzzlePiece\n    row::Int\n    col::Int\n    edges::Dict{CardinalDirection, Edge}\n\n    function SolvedPuzzlePiece(row, col)\n        new(row, col, Dict{CardinalDirection, Edge}())\n    end\nend\n\n\n\"\"\"\n    SolvedPuzzle(rows, columns)\n\nConstructs a `SolvedPuzzle` with the specified numbers of rows and\ncolumns.\n\nThe `grid` field is populated with `SolvedPuzzlePiece`s.\n\"\"\"\nstruct SolvedPuzzle\n    grid\n\n    function SolvedPuzzle(rows::Int, columns::Int)\n        sp = new(Array{SolvedPuzzlePiece, 2}(undef, rows, columns))\n        for r in 1:rows\n            for c in 1:columns\n                sp.grid[r, c] = SolvedPuzzlePiece(r, c)\n            end\n        end\n        sp\n    end\nend\n\nIt is conventient for SolvedPuzzle to serve as an indexible surrogate for its own grid of puzzle pieces.  We need getindex but not setindex!.\n\nFor out of bounds indecies we just return nothing rather than throwing an error.\n\nBase.size(sp::SolvedPuzzle) = size(sp.grid)\n\nBase.IndexStyle(sp::SolvedPuzzle) = IndexCartesian()\n\nfunction Base.getindex(sp::SolvedPuzzle, row::Int, col::Int)\n    (rows, cols) = size(sp)\n    if row < 1 || row > rows || col < 1 || col > cols\n        return nothing\n    end\n    sp.grid[row, col]\nend\n\nWe randomize the order of the EdgeTypes so they don't hint at the solution.\n\n\"\"\"\n    random_edge_types(count, is_perimeter)\n\nCreate the specified number of unique [`EdgeType`](@ref)s\nand returns them in a random order.\n\"\"\"\nfunction random_edge_types(count, is_perimeter)\n    edge_types = []\n    for _ in 1:count\n        push!(edge_types, EdgeType(is_perimeter))\n    end\n    shuffle(edge_types)\nend\n\n\n\"\"\"\n    assign_perimeter_edges(SolvedPuzzle)::SolvedPuzzle\n\nAssigns a unique [`EdgeType`](@ref) to the perimeter edge of each of\nthe perimeter puzzle pieces.\n\nThe `SolvedPuzzle` is returned.\n\"\"\"\nfunction assign_perimeter_edges(sp::SolvedPuzzle)::SolvedPuzzle\n    (rows, cols) = size(sp)\n    # We randomize the order of the EdgeTypes so they don't hint at\n    # the solution.\n    edge_types = random_edge_types(2 * rows + 2 * cols, true)\n    for r in 1:rows\n        # Top and bottom edges:\n        sp.grid[r, 1].edges[W()] = Edge(pop!(edge_types), Ball())\n        sp.grid[r, cols].edges[E()] = Edge(pop!(edge_types), Ball())\n    end\n    for c in 1:cols\n        # Left and right edges:\n        sp.grid[1, c].edges[N()] = Edge(pop!(edge_types), Ball())\n        sp.grid[rows, c].edges[S()] = Edge(pop!(edge_types), Ball())\n    end\n    sp\nend\n\n\n\"\"\"\n    assign_unique_unassigned_edges(sp::SolvedPuzzle)::SolvedPuzzle\n\nAssigns an [`EdgeType`](@ref)] to each of the *internal* edges of the\npuzzle.\n\nThe `SolvedPuzzle` is returned.\n\"\"\"\nfunction assign_unique_unassigned_edges(sp::SolvedPuzzle)::SolvedPuzzle\n    (rows, cols) = size(sp)\n    # It's ok to create too many EdgeTypes, they're cheap:\n    edge_types = random_edge_types(4 * rows * cols / 2, false)\n    for r in 1:rows\n        for c in 1:cols\n            do_cardinal_directions(; randomize=true) do direction\n                piece = sp[r, c]\n                if !haskey(piece.edges, direction)\n                    # Edge not yet assigned\n                    new_edge_type = pop!(edge_types)\n                    neignbor =\n                        sp[direction(piece.row, piece.col)...]\n                    # Maybe we should randomize which BallOrSocket to\n                    # use, but why bother?\n                    piece.edges[direction] = Edge(new_edge_type, Ball())\n                    if neignbor != nothing\n                        neignbor.edges[opposite(direction)] =\n                            Edge(new_edge_type, Socket())\n                    end\n                end\n            end\n        end\n    end\n    sp\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"solver/","page":"Solving","title":"Solving","text":"export edge_index_key, make_edge_index\nexport PuzzlePieceIncidenceGraph\nexport find_incidence_graph_connections\nexport Solver, add_one_piece, solve\n\nGiven the pieces of a puzzle, we want to see how many solutions we can find: how many different ways those pieces can be assembled.\n\nFor the pieces of a puzzle, we can produce an index mapping from EdgeType and BallOrSocket to the puzzle pieces having that EdgeType and BallOrSocket as an edge.\n\nconst EdgeIndexKey = Tuple{EdgeType, <:BallOrSocket}\n\nBase.isless(k1::EdgeIndexKey, k2::EdgeIndexKey) =\n    isless(k1[1], k2[1]) ||\n    (k1[1] == k2[1] && isless(k1[2], k2[2]))\n\nconst EdgeIndex = SortedDict{EdgeIndexKey,\n                             Vector{ImmutablePuzzlePiece}}\n\nedge_index_key(edge::Edge) = (edge.edge_type, edge.bs)\n\nfunction make_edge_index(pieces::Vector{ImmutablePuzzlePiece})\n    edge_index = SortedDict{EdgeIndexKey,\n                            Vector{ImmutablePuzzlePiece}}()\n    for piece in pieces\n        for edge in piece.edges\n            key = edge_index_key(edge)\n            if !haskey(edge_index, key)\n                edge_index[key] = ImmutablePuzzlePiece[]\n            end\n            push!(edge_index[key], piece)\n        end\n    end\n    edge_index\nend\n\nTo solve a puzzle, first we build an incidence graph where both axes are indexed by ImmutablePuzzlePiece.  That graph is represented by a square array.\n\nstruct PuzzlePieceIncidenceGraph\n    pieces::Vector{ImmutablePuzzlePiece}\n    incidence_graph\n\n    function PuzzlePieceIncidenceGraph(pieces)\n        l = length(pieces)\n        graph = new(pieces,\n                    Array{Any, 2}(missing, l, l))\n        for i in 1:l\n            for j in 1:l\n                graph.incidence_graph[i, j] = Tuple{Int64, Int64}[]\n            end\n        end\n        edge_index = make_edge_index(pieces)\n        for piece in pieces\n            for edge in piece.edges\n                if edge.bs isa Ball\n                    if !edge.edge_type.isperimeter\n                        for other in edge_index[(edge.edge_type,\n                                                 opposite(edge.bs))]\n                            if other == piece\n                                continue\n                            end\n                            mating_piece_indices(piece, other) do idx1, idx2\n                                push!(graph[piece, other],\n                                      (idx1, idx2))\n                            end\n                        end\n                    end\n                end\n            end\n        end\n        graph\n    end\nend\n\nfunction Base.getindex(g::PuzzlePieceIncidenceGraph,\n                       p1::ImmutablePuzzlePiece,\n                       p2::ImmutablePuzzlePiece)\n    r = findfirst(==(p1), g.pieces)\n    c = findfirst(==(p2), g.pieces)\n    g.incidence_graph[r, c]\nend\n\nfunction Base.setindex!(g::PuzzlePieceIncidenceGraph,\n                        new_value,\n                        p1::ImmutablePuzzlePiece,\n                       p2::ImmutablePuzzlePiece)\n    r = findfirst(==(p1), g.pieces)\n    c = findfirst(==(p2), g.pieces)\n    g.incidence_graph[r, c] = new_value\nend\n\n\nfunction find_incidence_graph_connections(graph::PuzzlePieceIncidenceGraph)\n    arcs = []\n    l = first(size(graph.incidence_graph))\n    for b in 1:l\n        for s in 1:l\n            for arc in graph.incidence_graph[b, s]\n                push!(arcs, (graph.pieces[b], arc[1],\n                             graph.pieces[s], arc[2]))\n            end\n        end\n    end\n    arcs\nend\n\nFor each possible solution, we assemble the puzzle pieces into a grid. That grid is square, and of the larger dimension of the originally generated puzzle.\n\nPuzzleSolutionGrid(size::Int) = Grid(missing, size, size)\n\nfunction PuzzleSolutionGrid(grid::Grid)\n    # Make a new grid that is a copy of grid.\n    l = first(size(grid))\n    new_grid = PuzzleSolutionGrid(l)\n    for r in 1:l\n        for c in 1:l\n            new_grid[r, c] = grid[r, c]\n        end\n    end\n    new_grid\nend\n\n\nstruct Solver\n    size::Int\n    all_pieces::Vector{ImmutablePuzzlePiece}\n    edge_index::EdgeIndex\n    incidence_graph::PuzzlePieceIncidenceGraph\n    working_grids::Vector{Grid}\n    solved_grids::Vector{Grid}\n\n    function Solver(puzzle_size,\n                    pieces::Vector{ImmutablePuzzlePiece})\n        pieces = sort(pieces)\n        size = max(puzzle_size...)\n        edge_index = make_edge_index(pieces)\n        incidence_graph = PuzzlePieceIncidenceGraph(pieces)\n        solver = new(size, pieces, edge_index, incidence_graph,\n                     Vector{Grid}(),\n                     Vector{Grid}())\n\nSeed the first grid with a corner\n\n        push!(solver.working_grids,\n              let\n                  grid = new_grid(solver)\n                  corner = pieces[1]\n                  @assert sum(isperimeter, corner.edges) >= 2\n                  grid[1, 1] = GridCell(1, 1, corner, 0)\n                  grid\n              end)\n        solver\n    end\nend\n\nnew_grid(solver::Solver) = Grid(missing, solver.size, solver.size)\n\nfunction finish_grid(solver::Solver, grid::Grid, issolved::Bool)\n    if issolved\n        push!(solver.solved_grids, grid)\n    end\n    deleteat!(solver.working_grids,\n              findall(g -> g === grid, solver.working_grids))\n    solver\nend\n\n\nfunction find_next_empty(grid)\n    (nrows, ncols) = size(grid)\n    for r in 1:nrows\n        for c in 1:ncols\n            cell = grid[r, c]\n            if cell isa GridCell\n                # We can trust that the edges aren't missing because\n                # Solver only deals with completed\n                # ImmutablePuzzlePiees.\n                if get_edge(cell, E()).edge_type.isperimeter\n                    if get_edge(cell, S()).edge_type.isperimeter\n                        return nothing\n                    end\n                    continue\n                end\n            else\n                return (r, c)\n            end\n        end\n    end\n    nothing\nend\n\n\n\"\"\"\n    add_one_piece(solver::Solver, grid::Grid)\n\nLooks for a piece to fit into the grid.  If there is more than one\nmating piece then additional grids are created for them.\n\"\"\"\nfunction add_one_piece(solver::Solver, grid::Grid)\n    next_empty_index = find_next_empty(grid)\n    if next_empty_index === nothing\n        finish_grid(solver, grid, true)\n        return\n    end\n    next_empty_index = Tuple(next_empty_index)\n    # Find a neighboring puzzle piece:\n    (neighbor, candidates) =\n        let\n            neighbor = nothing\n            candidates = nothing\n            for d in CARDINAL_DIRECTIONS\n                neighbor = d(grid, next_empty_index...)\n                if neighbor isa GridCell\n                    candidates = solver.edge_index[\n                        edge_index_key(opposite(get_edge(neighbor, opposite(d))))]\n                    break\n                end\n            end\n            (neighbor, candidates)\n        end\n    @assert neighbor isa GridCell\n    @assert candidates != nothing\n    fits = 0\n    for c in candidates\n        # Have we already used c in the puzzle?\n        if c in filter(cell -> (cell isa GridCell\n                                && c == cell.puzzle_piece),\n                       grid)\n            continue\n        end\n        (row, col) = next_empty_index\n        fit_piece(grid, row, col, c) do rot\n            # candidate fits with the given rotation\n            fits += 1\n            # If we've already put a piece in this location of this\n            # grid then add a new grid:\n            if !ismissing(grid[next_empty_index...])\n                grid = copy(grid)\n                push!(solver.working_grids, grid)\n            end\n            grid[row, col] = GridCell(row, col, c, rot)\n        end\n    end\n    if fits == 0\n        # We were not able too add a piece to this grid.  Don't do\n        # any more work on it.\n        finish_grid(solver, grid, false)\n    end\n    return\nend\n\n\"\"\"\n    solve(solver::Solver)\n\nRun the solver to find solutions to the jigsaw puzzle.\n\"\"\"\nfunction solve(solver::Solver)\n    while !isempty(solver.working_grids)\n        add_one_piece(solver, first(solver.working_grids))\n    end\nend\n\nfunction unused_pieces(grid::Grid, solver::Solver)\n    pieces_in_grid = map(grid) do cell\n        if cell isa GridCell\n            cell.puzzle_piece\n        end\n    end\n    unused = []\n    for piece in solver.all_pieces\n        if !(piece in pieces_in_grid)\n            push!(unused, piece)\n        end\n    end\n    unused\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"#MattParkerJigsawPuzzleProblem","page":"Home","title":"MattParkerJigsawPuzzleProblem","text":"Documentation for MattParkerJigsawPuzzleProblem.\n\nIn this YouTube video Matt Parker asks for a program to help design and solve jigsaw puzzles.\n\nThe idea is to produce a set of jigsaw puzzle pieces where the pieces can be assembled in more than one way, and, ideally, in exactly two ways.\n\nThis is an attempt at that.","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"Here is a simple usage example:\n\nusing MattParkerJigsawPuzzleProblem\n\nbegin\n    # Degenerate example of a puzzle, 2 × 2 grid\n    # with 4 possible solutions:\n    puzzle = MultipleSolutionPuzzle(2, 2, 4)\n    pieces = map(ImmutablePuzzlePiece, puzzle_pieces(puzzle))  \n    # Find the solutions and show them in HTML:\n    solver = Solver(size(puzzle), pieces)\n    solve(solver)\n    writing_html_file(\"two_by_two_example.html\") do\n        grids_to_html(solver.solved_grids)\n    end\n    length(solver.solved_grids)\nend\n\nSee the resulting solution grids: twobytwo_example.html\n\nThe rest of the documentation (see the menu in the corner above) presents the theory of operation.","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"#Descriptions","page":"Home","title":"Descriptions","text":"","category":"section"},{"location":"#MattParkerJigsawPuzzleProblem.ALL_EDGE_TYPES","page":"Home","title":"MattParkerJigsawPuzzleProblem.ALL_EDGE_TYPES","text":"ALL_EDGE_TYPES\n\nALL_EDGE_TYPES is a vector of all of the EdgeTypes that have been created.\n\n\n\n\n\n","category":"constant"},{"location":"#MattParkerJigsawPuzzleProblem.AbstractPuzzlePiece","page":"Home","title":"MattParkerJigsawPuzzleProblem.AbstractPuzzlePiece","text":"AbstractPuzzlePiece\n\nAbstractPuzzlePiece is the abstract supertype for all types of jigsaw puzzle piece.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.BallOrSocket","page":"Home","title":"MattParkerJigsawPuzzleProblem.BallOrSocket","text":"BallOrSocket\nBall\nSocket\nStraight\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.Edge","page":"Home","title":"MattParkerJigsawPuzzleProblem.Edge","text":"Edge(::EdgeType, ::BallOrSocket)\n\nEdge represents one edge of a puzzle piece.  It has an edge_type. The bs field indicates whether the edge is a ball or socket.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.EdgeType","page":"Home","title":"MattParkerJigsawPuzzleProblem.EdgeType","text":"EdgeType(isperimeter::Bool)\n\nCreates a unique EdgeType.\n\nisperimeter indicates if the EdgeType is for an edge on the perimeter of the puzzle.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.GridCell","page":"Home","title":"MattParkerJigsawPuzzleProblem.GridCell","text":"GridCell(::AbstractPuzzlePiece, rotation::Int)\n\nA GridCell is the container for a puzzle piece in a puzzle grid.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.ImmutablePuzzlePiece","page":"Home","title":"MattParkerJigsawPuzzleProblem.ImmutablePuzzlePiece","text":"ImmutablePuzzlePiece(from::MutablePuzzlePiece)\n\nConstructs an ImmutablePuzzlePiece from a MutablePuzzlePiece.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.MultipleSolutionPuzzle","page":"Home","title":"MattParkerJigsawPuzzleProblem.MultipleSolutionPuzzle","text":"MultipleSolutionPuzzle(number_of_rows, number_of_columns, number_of_grids)\n\nMultipleSolutionPuzzle is used to generate jigsaw puzzles with the specified numnber of rows and colukmns.  It will attempy to generate number_of_grids puzzles with the same pieces.  The pieces that are generated can be assembled least that number of of different ways. One must run the solver to see how many ways the pieces can actually be assembled.\n\nUse puzzle_pieces to get the pieces.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.MutablePuzzlePiece","page":"Home","title":"MattParkerJigsawPuzzleProblem.MutablePuzzlePiece","text":"MutablePuzzlePiece()\n\nConstructs a MutablePuzzlePiece with no edges defined yet.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.add_one_piece-Tuple{Solver, Matrix{Union{Missing, GridCell}}}","page":"Home","title":"MattParkerJigsawPuzzleProblem.add_one_piece","text":"add_one_piece(solver::Solver, grid::Grid)\n\nLooks for a piece to fit into the grid.  If there is more than one mating piece then additional grids are created for them.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.edge_index-Tuple{Int64}","page":"Home","title":"MattParkerJigsawPuzzleProblem.edge_index","text":"edge_index(::Int)::Int\n\nTurns the argument value into a valid edge index using the modulus operator.  This allows us to use aritmetic on edge indices and still get a valid index.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.edges_mate-Tuple{Edge, Edge}","page":"Home","title":"MattParkerJigsawPuzzleProblem.edges_mate","text":"edges_mate(::Edge, ::Edge)::Bool\n\nTwo Edges mate if they have the same EdgeType and their bss are opposites.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.fit_piece-Tuple{Any, Matrix{Union{Missing, GridCell}}, Int64, Int64, ImmutablePuzzlePiece}","page":"Home","title":"MattParkerJigsawPuzzleProblem.fit_piece","text":"fit_piece(continuation, grid::Grid, row::Int, col::Int,\n               piece::ImmutablePuzzlePiece)\n\nAttempts to fit piece into the specified location of grid. continuation is called for each rotation of piece that fits.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.get_neighboring_edge-Tuple{Matrix{Union{Missing, GridCell}}, Int64, Int64, CardinalDirection}","page":"Home","title":"MattParkerJigsawPuzzleProblem.get_neighboring_edge","text":"getneighboringedge(grid::Grid, row::Int, col::Int, direction::CardinalDirection) \n\nReturns the Edge of the \"neighboring cell\" to the specified grid location.  If that location is out of bounds then Edge(EdgeType(true, 0), Straight()) is returned.  Otherwise, if there is no GridCell at the specified location yet, then missing is returned.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.grid_to_html","page":"Home","title":"MattParkerJigsawPuzzleProblem.grid_to_html","text":"grid_to_html(grid::Grid, piece_numbers=nothing)\n\nGenerates HTML representing a tabular view of grid.\n\nIf piece_numbers is specified it is a Dict mapping from a puzzle piece to s small integer id to be printed in the center of the piece.\n\n\n\n\n\n","category":"function"},{"location":"#MattParkerJigsawPuzzleProblem.grids_to_html-Tuple{Vector{Matrix{Union{Missing, GridCell}}}}","page":"Home","title":"MattParkerJigsawPuzzleProblem.grids_to_html","text":"grids_to_html(grids::Vector{Grid})\n\nGenerates HTML elements for the grids.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.mating_piece_indices-Tuple{Any, ImmutablePuzzlePiece, ImmutablePuzzlePiece}","page":"Home","title":"MattParkerJigsawPuzzleProblem.mating_piece_indices","text":"mating_piece_indices(continuation, piece1::ImmutablePuzzlePiece, piece1::ImmutablePuzzlePiece)\n\nfor each Edge of piece1 that mates with an Edge of piece2, Calls continuation, on the indices into those two pieces of those mating edges.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.new_grid-Tuple{Any, Any}","page":"Home","title":"MattParkerJigsawPuzzleProblem.new_grid","text":"new_grid(number_of_rows, number_of_columns)::Grid\n\nCreates an empty puzzle grid of the specified dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.opposite-Tuple{N}","page":"Home","title":"MattParkerJigsawPuzzleProblem.opposite","text":"opposite(::CardinalDirection)::CardinalDirection\n\nReturns the opposite direction.  N() and S() are opposites. E() and W() are opposites.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.perimeter_edge_indices-Tuple{AbstractPuzzlePiece}","page":"Home","title":"MattParkerJigsawPuzzleProblem.perimeter_edge_indices","text":"perimeter_edge_indices(p::AbstractPuzzlePiece)\n\nReturns a vector of the indices of edges of the puzzle piece p that are perimeter edges.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.perimeter_edge_indices-Tuple{Matrix{Union{Missing, GridCell}}, Int64, Int64}","page":"Home","title":"MattParkerJigsawPuzzleProblem.perimeter_edge_indices","text":"perimeter_edge_indices(grid::Grid, row::int, col::Int)\n\nReturns a vector of the indices of edges of the specified cell of grid that are perimeter edges.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.perimeters-Tuple{MultipleSolutionPuzzle, Int64, Int64}","page":"Home","title":"MattParkerJigsawPuzzleProblem.perimeters","text":"perimeters(puzzle::MultipleSolutionPuzzle, row::Int, col::Int)\n\nReturns a four element vector indicating for each direction (N, E, S, W) whether that side of the cell at row, col is a perimeter of the puzzle.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.piece_edge-Tuple{AbstractPuzzlePiece, Any}","page":"Home","title":"MattParkerJigsawPuzzleProblem.piece_edge","text":"piece_edge(puzzle_piece, index)::Edge\n\nReturns the Edge of puzzle_piece which corresponds to the specified edge_index.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.puzzle_pieces-Tuple{MultipleSolutionPuzzle}","page":"Home","title":"MattParkerJigsawPuzzleProblem.puzzle_pieces","text":"puzzle_pieces(puzzle::MultipleSolutionPuzzle)::Vector{MutablePuzzlePiece}\n\nReturns a vector of all of the MutablePuzzlePieces of puzzle.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.rotation-Tuple{Int64}","page":"Home","title":"MattParkerJigsawPuzzleProblem.rotation","text":"rotation(rot::Int)\n\nNormalizes the rotation of the placement of a puzzle piece to one of 0, 1, 2, or 3.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.solve-Tuple{Solver}","page":"Home","title":"MattParkerJigsawPuzzleProblem.solve","text":"solve(solver::Solver)\n\nRun the solver to find solutions to the jigsaw puzzle.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.terserep-Tuple{MultipleSolutionPuzzle}","page":"Home","title":"MattParkerJigsawPuzzleProblem.terserep","text":"terserep(puzzle)\n\nOutput a terse printed representation of the puzzle.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.writing_html_file-Tuple{Any, Any}","page":"Home","title":"MattParkerJigsawPuzzleProblem.writing_html_file","text":"writing_html_file(body, filename)\n\nWrite an HTML file to filename.\n\nbody is a vector of elements to be included in the HTML document.\n\n\n\n\n\n","category":"method"},{"location":"grid_html/","page":"HTML Grid","title":"HTML Grid","text":"using Base.Iterators\nimport XML\nusing XML: Element\n\nexport writing_html_file, html_wrapper, grids_to_html, grid_to_html\n\nWe need an easy to understand representation of a puzze.  Here we generate an HTML grid from a puzzle grid.\n\nGRID_STYESHEET = \"\"\"\n\n.grid {\n    display: block;\n    margin: 2ex;\n    padding: 2ex;\n    border: solid yellow;\n}\n.GridCell {\n    display: grid;\n    gap: 10px;\n    grid-template-columns: repeat(3, 1fr);\n    grid-template-rows: repeat(3, 1fr);\n    margin: 0;\n    padding: 2;\n    border: solid yellow;\n}\n.Edge {\n    font-family: sans-serif;\n}\n.Edge.N {\n    display: in-line;\n    grid-row: 1;\n    grid-column: 2:\n    text-align: center;\n}\n.Edge.E {\n    display: in-line;\n    grid-row: 2;\n    grid-column: 3:\n    text-align: end;\n}\n.Edge.S {\n    display: in-line;\n    grid-row: 3;\n    grid-column: 2:\n    text-align: center;\n}\n.Edge.W {\n    display: in-line;\n    grid-row: 2;\n    grid-column: 1:\n    text-align: start;\n}\n.piece_number {\n    display: in-line;\n    grid-row: 2;\n    grid-column: 2:\n    margin: 3em;\n    font-weight: bold;\n    text-align: center;\n}\n\"\"\"\n\n\"\"\"\n    writing_html_file(body, filename)\n\nWrite an HTML file to `filename`.\n\n`body` is a vector of elements to be included in the HTML document.\n\"\"\"\nfunction writing_html_file(body, filename)\n    # body should return a vector of HTML Elements.\n    XML.write(filename,\n              html_wrapper(body());\n              indentsize=2)\nend\n\nfunction html_wrapper(body_elements)\n    Element(\n        \"html\",\n        Element(\n            \"head\",\n            Element(\"style\", GRID_STYESHEET)),\n        Element(\n            \"body\", body_elements...)\n    )\nend\n\n\n\"\"\"\n    grids_to_html(grids::Vector{Grid})\n\nGenerates HTML elements for the grids.\n\"\"\"\nfunction grids_to_html(grids::Vector{Grid})\n    all_pieces = Set()\n    for grid in grids\n        (nrows, ncols) = size(grid)\n        for row in 1:nrows\n            for col in 1:ncols\n                cell = grid[row, col]\n                if cell isa GridCell\n                    push!(all_pieces, cell.puzzle_piece)\n                end\n            end\n        end\n    end\n    piece_numbers = Dict{AbstractPuzzlePiece, Int}()\n    for (i, p) in enumerate(all_pieces)\n        piece_numbers[p] = i\n    end\n    map(g -> grid_to_html(g, piece_numbers),\n        grids)\nend\n\n\n\"\"\"\n    grid_to_html(grid::Grid, piece_numbers=nothing)\n\nGenerates HTML representing a tabular view of `grid`.\n\nIf `piece_numbers` is specified it is a Dict mapping from a puzzle\npiece to s small integer id to be printed in the center of the piece.\n\"\"\"\nfunction grid_to_html(grid::Grid, piece_numbers=nothing)\n    function piece_number(cell::GridCell)\n        if piece_numbers isa Dict\n            string(piece_numbers[cell.puzzle_piece])\n        else\n            \"\"\n        end\n    end\n    (nrows, ncols) = size(grid)\n    Element(\n        \"div\",\n        Element(\n            \"table\",\n            [ Element(\n                \"tr\",\n                [\n                    Element(\n                        \"td\",\n                        Element(\n                            \"div\",\n                            let\n                                cell = grid[row, col]\n                                if cell isa GridCell\n                                    edges = []\n                                    for d in [N(), W(), E(), S()]\n                                        edge = get_edge(cell, d)\n                                        # Maybe do something to highlight\n                                        # mismatched edges.\n                                        push!(edges,\n                                              Element(\n                                                  \"div\",\n                                                  terserep(edge);\n                                                  class=\"Edge $(string(typeof(d)))\"))\n                                        if d isa W\n                                            push!(edges,\n                                                  Element(\n                                                      \"div\",\n                                                      piece_number(cell);\n                                                      class=\"piece_number\"))\n                                        end\n                                    end\n                                    edges\n                                else\n                                    [ \"&nbsp\" ]\n                                end\n                            end...;\n                            class=\"GridCell\")\n                    )\n                    for col in 1:ncols\n                        ]...\n                            )\n              for row in 1:nrows ]...);\n    class=\"grid\")\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"edges/","page":"Edges","title":"Edges","text":"export ALL_EDGE_TYPES, EdgeType\nexport BallOrSocket, Ball, Socket, Straight\nexport opposite, Edge, isperimeter, edges_mate\n\nWe define some number of \"edge types\".  If the puzzle pieces are all square, then there is only one edge type.  If they are rectangular then there are two edge types: one for each edge length.  Each different shape of interlocking edge represents another edge type.\n\nMORE PRACTICALLY THOUGH: since we don't want to match two puzzle pieces on a flat perimeter edge, each edge on the perimeter of the puzzle should have a different edge type.  For a 3 by 5 puzzle, that gives 16 edge types before you start defining edge types for the internal edges.\n\nWe define EdgeType and create an instance for each distinct edge type. All an EdgeType needs is uniqueness.  It might be handy to note if the EdgeType represents a perimeter edge though, so we track that.\n\nWe accumulate a catalog of every EdgeType in ALL_EDGE_TYPES.\n\n\"\"\"\n    ALL_EDGE_TYPES\n\n`ALL_EDGE_TYPES` is a vector of all of the `EdgeType`s that have been\ncreated.\n\"\"\"\nALL_EDGE_TYPES = []\n\nlet\n    NEXT_EDGE_UID = 1\n\n    struct EdgeType\n        isperimeter::Bool\n        uid::Int\n\n        # For testing:\n        EdgeType(isperimeter, uid) = new(isperimeter, uid)\n\n        function EdgeType(isperimeter)\n            et = new(isperimeter,\n                     let\n                         uid = NEXT_EDGE_UID\n                         NEXT_EDGE_UID += 1\n                         uid\n                     end)\n            push!(ALL_EDGE_TYPES, et)\n            return et\n        end\n    end\nend\n\n@doc \"\"\"\n    EdgeType(isperimeter::Bool)\n\nCreates a unique `EdgeType`.\n\n`isperimeter` indicates if the EdgeType is for an edge on the\nperimeter of the puzzle.\n\"\"\" EdgeType\n\n\nisperimeter(e::EdgeType) = e.isperimeter\n\nAt the edge where two puzzle pieces interlock, the edges of those pieces are mirror images of each other.  At that meeting edge, one piece has a ball and the other has a socket.  If the edge is at the border of the puzzle then it is straight.\n\nThe edge of a puzzle piece is thus characterized by its EdgeType and whether it is a ball, socket, or straight.\n\nBall and Socket are opposites.\n\nStraight is its own opposite.\n\n\"\"\"\n    BallOrSocket\n    Ball\n    Socket\n    Straight\n\"\"\"\nabstract type BallOrSocket end\nstruct Ball <: BallOrSocket end\nstruct Socket <: BallOrSocket end\nstruct Straight <: BallOrSocket end\n\nopposite(::Ball) = Socket()\nopposite(::Socket) = Ball()\nopposite(::Straight) = Straight()\n\n\n\"\"\"\n    Edge(::EdgeType, ::BallOrSocket)\n\n`Edge` represents one edge of a puzzle piece.  It has an `edge_type`.\nThe `bs` field indicates whether the edge is a *ball* or *socket*.\n\n\"\"\"\nstruct Edge\n    edge_type::EdgeType\n    bs::BallOrSocket\nend\n\nisperimeter(e::Edge) = isperimeter(e.edge_type)\nisperimeter(::Missing) = false\n\nopposite(edge::Edge) = Edge(edge.edge_type, opposite(edge.bs))\n\nIt is easier to index things if there is a total ordering defined for them.\n\nEdgeTypes can be ordered by their uid.\n\nWe arbitrarily decide that Ball comes before Socket.\n\nWe can then define a total ordering on Edges.\n\nfunction Base.isless(a::EdgeType, b::EdgeType)::Bool\n    a.uid < b.uid\nend\n\nBase.isless(::BallOrSocket, ::BallOrSocket) = false\nBase.isless(::Ball, ::Socket) = true\nBase.isless(::Ball, ::Straight) = true\nBase.isless(::Socket, ::Straight) = true\n\nfunction Base.isless(a::Edge, b::Edge)\n    (isless(a.edge_type, b.edge_type) ||\n        (a.edge_type == b.edge_type &&\n        isless(a.bs, b.bs)))\nend\n\nTwo Edges match if they have the same EdgeType and their bss are opposites.\n\n\"\"\"\n    edges_mate(::Edge, ::Edge)::Bool\n\nTwo `Edge`s mate if they have the same `EdgeType` and their `bs`s are\nopposites.\n\"\"\"\nfunction edges_mate(e1::Edge, e2::Edge)::Bool\n    # For perimeter edges the EdgeType doesn't matter:\n    (e1.bs == e2.bs == Straight()) ||\n        ((e1.edge_type == e2.edge_type) &&\n        (opposite(e1.bs) == e2.bs))\nend\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
