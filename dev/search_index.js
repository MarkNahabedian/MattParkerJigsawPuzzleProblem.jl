var documenterSearchIndex = {"docs":
[{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"EditURL = \"../../src/MattParkerJigsawPuzzleProblem.jl\"","category":"page"},{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"module MattParkerJigsawPuzzleProblem\n\nusing Markdown\nusing Literate\nusing InteractiveUtils\nusing Random\n\ninclude(\"edges.jl\")\ninclude(\"solved_puzzle.jl\")\n\nend","category":"page"},{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"","category":"page"},{"location":"MattParkerJigsawPuzzleProblem/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"EditURL = \"../../src/solved_puzzle.jl\"","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"export CardinalDirection, N, E, S, W\nexport SolvedPuzzlePiece, SolvedPuzzle\nexport neighbor_coordinates, do_cardinal_directions\nexport assign_perimeter_edges, assign_unique_unassigned_edges","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"We can construct a solved puzzle of a specified size by creating puzzle pieces that fit together into a solution.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"In the solution of a puzzle, each piece has a unique location (row and column) and one of four rotations.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"Each edge of a piece, in its solved orientation, can be identified by a cardinal compass direction: n, e, s, or w.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"abstract type CardinalDirection end\nstruct N <: CardinalDirection end\nstruct E <: CardinalDirection end\nstruct S <: CardinalDirection end\nstruct W <: CardinalDirection end","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"do_cardinal_directions allows us to easily iterate over the cardinal directions.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"\"\"\"\n    do_cardinal_directions(f; randomize=false)\n\nApplies the function `f` to each of the four cardinal directions.\n\nIf `randomize` is true then the directions are considered in random\norder.\n\"\"\"\nfunction do_cardinal_directions(f; randomize=false)\n    directions = subtypes(CardinalDirection)\n    if randomize\n        directions = Random.shuffle(directions)\n    end\n    for dt in directions\n        f(dt())\n    end\nend","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"For each cardinal compass direction, there is the opposite dirtection.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"For two puzzle pieces that share a vertical edge, the piece on the left's E edge will have the same EdgeType as that of the W edge of the piece on the right.  The will have opposite BallOrSockets.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"opposite(::N) = S()\nopposite(::E) = W()\nopposite(::S) = N()\nopposite(::W) = E()\n\n\n\"\"\"\n    SolvedPuzzlePiece(row, column)\n\nRepresents the piece of a `SolvedPuzzle` at the specified `row` and\n`column`.\n\nThe `edges` field is a `Dict` which maps from a `CardinalDirection`\nto and [`Edge`](@ref).\n\"\"\"\nstruct SolvedPuzzlePiece\n    row::Int\n    col::Int\n    edges::Dict{CardinalDirection, Edge}\n\n    function SolvedPuzzlePiece(row, col)\n        new(row, col, Dict{CardinalDirection, Edge}())\n    end\nend\n\n\n\"\"\"\n    SolvedPuzzle(rows, columns)\n\nConstructs a `SolvedPuzzle` with the specified numbers of rows and\ncolumns.\n\nThe `grid` field is populated with `SolvedPuzzlePiece`s.\n\"\"\"\nstruct SolvedPuzzle\n    grid\n\n    function SolvedPuzzle(rows::Int, columns::Int)\n        sp = new(Array{SolvedPuzzlePiece, 2}(undef, rows, columns))\n        for r in 1:rows\n            for c in 1:columns\n                sp.grid[r, c] = SolvedPuzzlePiece(r, c)\n            end\n        end\n        sp\n    end\nend","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"It is conventient for SolvedPuzzle to serve as an indexible surrogate for its own grid of puzzle pieces.  We need getindex but not setindex!.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"For out ofbounds indecies we just return nothing rather than throwing an error.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"Base.size(sp::SolvedPuzzle) = size(sp.grid)\n\nBase.IndexStyle(sp::SolvedPuzzle) = IndexCartesian()\n\nfunction Base.getindex(sp::SolvedPuzzle, row::Int, col::Int)\n    (rows, cols) = size(sp)\n    if row < 1 || row > rows || col < 1 || col > cols\n        return nothing\n    end\n    sp.grid[row, col]\nend\n\n\nneighbor_coordinates(spp::SolvedPuzzlePiece, ::N) = [spp.row - 1, spp.col]\nneighbor_coordinates(spp::SolvedPuzzlePiece, ::E) = [spp.row, spp.col + 1]\nneighbor_coordinates(spp::SolvedPuzzlePiece, ::S) = [spp.row + 1, spp.col]\nneighbor_coordinates(spp::SolvedPuzzlePiece, ::W) = [spp.row, spp.col - 1]","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"We randomize the order of the EdgeTypes so they don't hint at the solution.","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"\"\"\"\n    random_edge_types(count, is_perimeter)\n\nCreate the specified number of unique [`EdgeType`](@ref)s\nand returns them in a random order.\n\"\"\"\nfunction random_edge_types(count, is_perimeter)\n    edge_types = []\n    for _ in 1:count\n        push!(edge_types, EdgeType(is_perimeter))\n    end\n    shuffle(edge_types)\nend\n\n\n\"\"\"\n    assign_perimeter_edges(SolvedPuzzle)::SolvedPuzzle\n\nAssigns a unique [`EdgeType`](@ref) to the perimeter edge of each of\nthe perimeter puzzle pieces.\n\nThe `SolvedPuzzle` is returned.\n\"\"\"\nfunction assign_perimeter_edges(sp::SolvedPuzzle)::SolvedPuzzle\n    (rows, cols) = size(sp)\n    # We randomize the order of the EdgeTypes so they don't hint at\n    # the solution.\n    edge_types = random_edge_types(2 * rows + 2 * cols, true)\n    for r in 1:rows\n        # Top and bottom edges:\n        sp.grid[r, 1].edges[W()] = Edge(pop!(edge_types), Ball())\n        sp.grid[r, cols].edges[E()] = Edge(pop!(edge_types), Ball())\n    end\n    for c in 1:cols\n        # Left and right edges:\n        sp.grid[1, c].edges[N()] = Edge(pop!(edge_types), Ball())\n        sp.grid[rows, c].edges[S()] = Edge(pop!(edge_types), Ball())\n    end\n    sp\nend\n\n\n\"\"\"\n    assign_unique_unassigned_edges(sp::SolvedPuzzle)::SolvedPuzzle\n\nAssigns an [`EdgeType`](@ref)] to each of the *internal* edges of the\npuzzle.\n\nThe `SolvedPuzzle` is returned.\n\"\"\"\nfunction assign_unique_unassigned_edges(sp::SolvedPuzzle)::SolvedPuzzle\n    (rows, cols) = size(sp)","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"It's ok to create too many EdgeTypes, they're cheap:","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"    edge_types = random_edge_types(4 * rows * cols / 2, false)\n    for r in 1:rows\n        for c in 1:cols\n            do_cardinal_directions(; randomize=true) do direction\n                piece = sp[r, c]\n                if !haskey(piece.edges, direction)\n                    # Edge not yet assigned\n                    new_edge_type = pop!(edge_types)\n                    neignbor =\n                        sp[neighbor_coordinates(piece, direction)...]\n                    # Maybe we should randomize which BallOrSocket to\n                    # use, but why bother?\n                    piece.edges[direction] = Edge(new_edge_type, Ball())\n                    if neignbor != nothing\n                        neignbor.edges[opposite(direction)] =\n                            Edge(new_edge_type, Socket())\n                    end\n                end\n            end\n        end\n    end\n    sp\nend","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"","category":"page"},{"location":"solved_puzzle/","page":"SolvedPuzzle","title":"SolvedPuzzle","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = MattParkerJigsawPuzzleProblem","category":"page"},{"location":"#MattParkerJigsawPuzzleProblem","page":"Home","title":"MattParkerJigsawPuzzleProblem","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for MattParkerJigsawPuzzleProblem.","category":"page"},{"location":"","page":"Home","title":"Home","text":"In this YouTube video Matt Parker asks for a program to help design and solve jigsaw puzzles.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The idea is to produce a set of jigsaw puzzle pieces where the pieces can be assembled in more than one way, and, ideally, in exactly two ways.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This is an attempt at that.","category":"page"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Descriptions","page":"Home","title":"Descriptions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Modules = [MattParkerJigsawPuzzleProblem]","category":"page"},{"location":"#MattParkerJigsawPuzzleProblem.ALL_EDGE_TYPES","page":"Home","title":"MattParkerJigsawPuzzleProblem.ALL_EDGE_TYPES","text":"ALL_EDGE_TYPES\n\nALL_EDGE_TYPES is a vector of all of the EdgeTypes that have been created.\n\n\n\n\n\n","category":"constant"},{"location":"#MattParkerJigsawPuzzleProblem.Edge","page":"Home","title":"MattParkerJigsawPuzzleProblem.Edge","text":"Edge(::EdgeType, ::BallOrSocket)\n\nEdge represents one edge of a puzzle piece.  It has an edge_type. The bs field indicates whether the edge is a ball or socket.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.EdgeType","page":"Home","title":"MattParkerJigsawPuzzleProblem.EdgeType","text":"EdgeType(isperimeter::Bool)\n\nCreates a unique EdgeType.\n\nisperimeter indicates if the EdgeType is for an edge on the perimeter of the puzzle.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.SolvedPuzzle","page":"Home","title":"MattParkerJigsawPuzzleProblem.SolvedPuzzle","text":"SolvedPuzzle(rows, columns)\n\nConstructs a SolvedPuzzle with the specified numbers of rows and columns.\n\nThe grid field is populated with SolvedPuzzlePieces.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.SolvedPuzzlePiece","page":"Home","title":"MattParkerJigsawPuzzleProblem.SolvedPuzzlePiece","text":"SolvedPuzzlePiece(row, column)\n\nRepresents the piece of a SolvedPuzzle at the specified row and column.\n\nThe edges field is a Dict which maps from a CardinalDirection to and Edge.\n\n\n\n\n\n","category":"type"},{"location":"#MattParkerJigsawPuzzleProblem.assign_perimeter_edges-Tuple{SolvedPuzzle}","page":"Home","title":"MattParkerJigsawPuzzleProblem.assign_perimeter_edges","text":"assign_perimeter_edges(SolvedPuzzle)::SolvedPuzzle\n\nAssigns a unique EdgeType to the perimeter edge of each of the perimeter puzzle pieces.\n\nThe SolvedPuzzle is returned.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.assign_unique_unassigned_edges-Tuple{SolvedPuzzle}","page":"Home","title":"MattParkerJigsawPuzzleProblem.assign_unique_unassigned_edges","text":"assign_unique_unassigned_edges(sp::SolvedPuzzle)::SolvedPuzzle\n\nAssigns an EdgeType] to each of the internal edges of the puzzle.\n\nThe SolvedPuzzle is returned.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.do_cardinal_directions-Tuple{Any}","page":"Home","title":"MattParkerJigsawPuzzleProblem.do_cardinal_directions","text":"do_cardinal_directions(f; randomize=false)\n\nApplies the function f to each of the four cardinal directions.\n\nIf randomize is true then the directions are considered in random order.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.edges_match-Tuple{Edge, Edge}","page":"Home","title":"MattParkerJigsawPuzzleProblem.edges_match","text":"edges_match(::Edge, ::Edge)::Bool\n\nTwo Edges match if they have the same EdgeType and their bss are opposites.\n\n\n\n\n\n","category":"method"},{"location":"#MattParkerJigsawPuzzleProblem.random_edge_types-Tuple{Any, Any}","page":"Home","title":"MattParkerJigsawPuzzleProblem.random_edge_types","text":"random_edge_types(count, is_perimeter)\n\nCreate the specified number of unique EdgeTypes  and returns them in a random order.\n\n\n\n\n\n","category":"method"},{"location":"edges/","page":"Edges","title":"Edges","text":"EditURL = \"../../src/edges.jl\"","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"export ALL_EDGE_TYPES, EdgeType, BallOrSocket, Ball, Socket\nexport opposite, Edge, edges_match","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We define some number of \"edge types\".  If the puzzle pieces are all square, then there is only one edge type.  If they are rectangular then there are two edge types: one for each edge length.  Each different shape of interlocking edge represents another edge type.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"MORE PRACTICALLY THOUGH: since we don't want to match two puzzle pieces on a flat perimeter edge, each edge on the perimeter of the puzzle should have a different edge type.  For a 3 by 5 puzzle that gives 16 edge types before you start defining edge types for the internal edges.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We define EdgeType and create an instance for each distinct edge type. All an EdgeType needs is uniqueness.  It might be handy to note if the EdgeType represents a perimeter edge though, so we track that.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We accumulate a catalog of every EdgeType in ALL_EDGE_TYPES.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"\"\"\"\n    ALL_EDGE_TYPES\n\n`ALL_EDGE_TYPES` is a vector of all of the `EdgeType`s that have been\ncreated.\n\"\"\"\nALL_EDGE_TYPES = []\n\nlet\n    NEXT_EDGE_UID = 1\n\n    struct EdgeType\n        isperimeter::Bool\n        uid::Int\n\n        function EdgeType(isperimeter)\n            et = new(isperimeter,\n                     let\n                         uid = NEXT_EDGE_UID\n                         NEXT_EDGE_UID += 1\n                         uid\n                     end)\n            push!(ALL_EDGE_TYPES, et)\n            return et\n        end\n    end\nend\n\n@doc \"\"\"\n    EdgeType(isperimeter::Bool)\n\nCreates a unique `EdgeType`.\n\n`isperimeter` indicates if the EdgeType is for an edge on the\nperimeter of the puzzle.\n\"\"\" EdgeType","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"At the edge where two puzzle pieces interlock, the edges of those pieces are mirror images of each other.  At that meeting edge, one piece has a ball and the other has a socket.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"The edge of a puzzle piece is thus characterized by its EdgeType and whether it is a ball or socket.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"Ball and Socket are opposites.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"We arbitrarily decide that a perimeter edge is always a ball.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"abstract type BallOrSocket end\nstruct Ball <: BallOrSocket end\nstruct Socket <: BallOrSocket end\n\nopposite(::Ball) = Socket()\nopposite(::Socket) = Ball()\n\n\n\"\"\"\n    Edge(::EdgeType, ::BallOrSocket)\n\n`Edge` represents one edge of a puzzle piece.  It has an `edge_type`.\nThe `bs` field indicates whether the edge is a *ball* or *socket*.\n\n\"\"\"\nstruct Edge\n    edge_type::EdgeType\n    bs::BallOrSocket\nend","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"It is easier to index things if there is a total ordering defined for them.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"EdgeTypes can be ordered by their uid.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"Wearbitrarily decide that Ball comes before Socket.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"function Base.isless(a::EdgeType, b::EdgeType)::Bool\n    a.uid < b.uid\nend\n\nfunction Base.isless(a::BallOrSocket, b::BallOrSocket)\n    false\nend\n\nfunction Base.isless(::Ball, ::Socket)\n    true\nend","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"Two Edges match if they have the same EdgeType and their bss are opposites.","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"\"\"\"\n    edges_match(::Edge, ::Edge)::Bool\n\nTwo `Edge`s match if they have the same `EdgeType` and their `bs`s are\nopposites.\n\"\"\"\nfunction edges_match(e1::Edge, e2::Edge)::Bool\n    (e1.edge_type == e2.edge_type) &&\n        (opposite(e1.bs) == e2.bs)\nend","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"","category":"page"},{"location":"edges/","page":"Edges","title":"Edges","text":"This page was generated using Literate.jl.","category":"page"}]
}
